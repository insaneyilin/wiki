<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>C++ 序列化 - Yilin's Wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          <!--$表示行内元素，$$表示块状元素 -->
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <!--Mermaid流程图-->
    <script src="https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#c++">c++</a>&nbsp;&#187;&nbsp;C++ 序列化
    <span class="updated">Page Updated&nbsp;
      2020-05-22 20:00
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">C++ 序列化</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">什么是序列化</a></li>
<li><a href="#_2">为什么需要序列化</a></li>
<li><a href="#c">常见 C++ 序列化方式</a></li>
<li><a href="#_3">参考</a></li>
</ul>
</div>
<hr />
<h2 id="_1">什么是序列化</h2>
<p>程序员在编写应用程序的时候往往需要将程序的某些数据存储在内存中，然后将其写入某个文件或是将它传输到网络中的另一台计算机上以实现通讯。这个 <strong>将程序数据转化成能被存储并传输的格式的过程</strong> 被称为“序列化”（Serialization），而它的逆过程则可被称为“反序列化” （Deserialization）。</p>
<p>简单来说，序列化就是将对象实例的状态转换为可保持或传输的格式的过程。与序列化相对的是反序列化，它根据流重构对象。这两个过程结合起来，可以轻 松地存储和传输数据。例如，可以序列化一个对象，然后使用 HTTP 通过 Internet 在客户端和服务器之间传输该对象。</p>
<p>总结：</p>
<ul>
<li>序列化：将对象变成字节流的形式传出去。</li>
<li>反序列化：从字节流恢复成原来的对象。</li>
</ul>
<h2 id="_2">为什么需要序列化</h2>
<p>简单来说，对象序列化通常用于两个目的： </p>
<ul>
<li>将对象存储于硬盘上，便于以后反序列化使用；</li>
<li>在网络上传输对象的字节序列。</li>
</ul>
<p>对象序列化的好处在哪里？</p>
<p>网络传输上的便捷性、灵活性。</p>
<p>缓存计算结果，节省时间。例子：你有一个数据结构，里面存储的数据是经过很多其它数据通过 <strong>非常复杂的算法</strong> 生成的，由于数据量很大，算法又复杂，因此生成该数据结构所用数据的时间可能要很久（也许几个小时，甚至几天），生成该数据结构后又要用作其它的计算，那么你在调试阶段，每次运行个程序，就光生成数据结构就要花上这么长的时间，无疑代价是非常大的。如果你确定生成数据结构的算法不会变或不常变，那么就可以通过序列化技术生成数据结构数据存储到磁盘上，下次重新运行程序时只需要从磁盘上读取该对象数据即可，所花费时间也就 <strong>读一个文件的时间</strong> ，可想而知是多么的快， <strong>节省了我们的开发时间</strong> 。</p>
<h2 id="c">常见 C++ 序列化方式</h2>
<ul>
<li>Google Protocol Buffers（protobuf）</li>
<li>Boost.Serialization</li>
</ul>
<h2 id="_3">参考</h2>
<p>http://www.cnblogs.com/lanxuezaipiao/p/3703988.html</p>
  <div class="relation">
    <h2>Related</h2>
    <ul>
    
    <li><a href="/wiki/c++/cxx_std_io_tips.html">C++ Standard IO tips</a></li>
    
    <li><a href="/wiki/c++/cxx11_multi_thread_and_async.html">C++11 多线程与异步调用</a></li>
    
    <li><a href="/wiki/c++/cxx_practical_tips.html">C++ Practical Tips</a></li>
    
    <li><a href="/wiki/c++/cxx_type_casting.html">C++ 类型转换</a></li>
    
    <li><a href="/wiki/c++/effective_stl_notes.html">Effective STL notes</a></li>
    
    <li><a href="/wiki/c++/eigen_notes.html">Eigen C++ Library cheatsheet</a></li>
    
    </ul>
  </div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2020 Yilin Gui.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2020-06-01 01:35:58</p>
      </span>
    </div>

    
    
  </body>
</html>