<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>剑指offer笔记(1) - Yilin's Wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          <!--$表示行内元素，$$表示块状元素 -->
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <!--Mermaid流程图-->
    <script src="https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#job_interviews">job_interviews</a>&nbsp;&#187;&nbsp;剑指offer笔记(1)
    <span class="updated">Page Updated&nbsp;
      2019-07-12 01:34
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">剑指offer笔记(1)</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">第一章 面试流程</a></li>
<li><a href="#_2">第二章 面试所需要的基础知识</a><ul>
<li><a href="#c4">C++中有哪4个与类型转换相关的关键字，分别应该在什么场合下被使用？</a></li>
<li><a href="#c-sizeof">C++ 空类型的 sizeof</a></li>
<li><a href="#c">C++ 拷贝构造函数定义</a></li>
<li><a href="#1">面试题1：赋值运算符的实现</a></li>
<li><a href="#2">面试题2：单例模式的实现</a><ul>
<li><a href="#lazy-singleton">Lazy Singleton</a></li>
<li><a href="#eager-singleton">Eager Singleton</a></li>
<li><a href="#meyers-singleton">Meyers Singleton</a></li>
</ul>
</li>
<li><a href="#3">面试题3：二维数组中的查找</a></li>
<li><a href="#c_1">C 语言风格字符串</a></li>
<li><a href="#4">面试题4：替换空格</a></li>
<li><a href="#_3">链表</a></li>
<li><a href="#5">面试题5：从尾到头打印链表</a></li>
<li><a href="#6">面试题6：重建二叉树</a></li>
<li><a href="#7">面试题7：用两个栈实现一个队列</a></li>
<li><a href="#7-2">面试题7-2：用两个队列实现一个栈</a></li>
<li><a href="#_4">查找与排序</a></li>
<li><a href="#8">面试题8：旋转数组中的最小元素</a></li>
<li><a href="#9">面试题9：斐波那契数列</a></li>
<li><a href="#_5">变态跳台阶</a></li>
<li><a href="#10-1">面试题10：二进制中 1 的个数</a></li>
</ul>
</li>
</ul>
</div>
<p><a href="https://book.douban.com/subject/27008702/">《剑指Offer》(应该是第一版)</a> 读书笔记。</p>
<h2 id="_1">第一章 面试流程</h2>
<p>面试的形式：</p>
<ul>
<li>电话面试</li>
<li>远程共享桌面面试</li>
<li>现场面试</li>
</ul>
<p>电话面试：</p>
<ul>
<li>尽可能用形象的语言描述方法；</li>
<li>没有听清或者听懂面试官的问题，敢于提问，尤其是英文面试。</li>
</ul>
<p>对于远程共享桌面面试，一般是当场编码：</p>
<ul>
<li>想清楚再开始写代码；</li>
<li>编码规范；</li>
<li>单元测试：如果在写完一个函数后进行单元测试，相当于向面试官证明了自己的开发经验。现在能做到“测试在前，开发在后”的人并不多；</li>
<li>调试时的表现：设置断点，单步跟踪，查看内存，分析调用栈等。</li>
</ul>
<p>现场面试：</p>
<ul>
<li>时间、地点</li>
<li>面试流程</li>
<li>准备一些问题</li>
</ul>
<p>行为面试：</p>
<ul>
<li>自我介绍，面试官针对简历问问题。</li>
</ul>
<p>关于简历中的项目经历：</p>
<ul>
<li>STAR （Situation -&gt; Task -&gt; Action -&gt; Result）</li>
<li>Situation，简短介绍项目背景</li>
<li>Task，任务是什么</li>
<li>Action，为了完成任务做了哪些工作，怎么做的（区分“参与”和“负责”，突出自己的工作）</li>
<li>Result，自己的贡献</li>
</ul>
<p>一个介绍项目经历的例子：</p>
<blockquote>
<p>微软 Winforms 是微软 .NET 中的一个 UI 平台（Situation），本人的工作是在添加少量新功能之外负责维护已有的功能（Task）。新的功能主要是让 Winforms 控件的风格和 Win7 的风格保持一致。在维护方面，对于较难的问题我能使用 WinDbg 等工具进行调试（Action）。在过去两年中我总共修改了超过 200 个 Bug（Result）。</p>
</blockquote>
<p>对于项目还有可能被问到如下问题：</p>
<ul>
<li>项目中遇到的最大的问题是什么？如何解决的？</li>
<li>从项目中学到了什么？</li>
<li>团队成员之间如何进行沟通、合作？如何解决冲突？</li>
</ul>
<p>关于简历中的技能：</p>
<ul>
<li>区分“了解”、“熟悉”、“精通”</li>
<li>简历中大部分技能应该达到“熟悉”的程度</li>
</ul>
<p>为什么跳槽：</p>
<ul>
<li>避免说上一份工作的“坏话”</li>
</ul>
<p>技术面试：</p>
<ul>
<li>简单的问题也要考虑 corner case</li>
<li>复杂的问题<ul>
<li>画图</li>
<li>举例</li>
<li>分解</li>
</ul>
</li>
<li>优化算法效率的能力<ul>
<li>时间复杂度、空间复杂度</li>
<li>算法、数据结构的适用场合和优缺点</li>
</ul>
</li>
<li>知识迁移、发散思维、抽象建模</li>
</ul>
<p>提问环节：</p>
<ul>
<li>少问隐私</li>
<li>多问岗位、业务相关问题</li>
</ul>
<hr />
<h2 id="_2">第二章 面试所需要的基础知识</h2>
<h4 id="c4">C++中有哪4个与类型转换相关的关键字，分别应该在什么场合下被使用？</h4>
<ul>
<li>static_cast: 静态转换，在编译处理期间转换，无运行时类型检测来保证转换安全性。常用于内置类型转换/子类指针转基类指针；注意用 static_cast 将基类指针转子类指针是非安全的。</li>
<li>const_cast: 将非 const 类型转 const ；或者去 const 属性</li>
<li>reinterpret_cast: 有着和c风格强制类型转换同样的功能；它可以转化任何的内置数据类型为其他的类型，同时它也可以把任何类型的指针转化为其他的类型；它的机理是对二进制进行重新的解释，不会改变原来的格式。</li>
<li>dynamic_cast: dynamic_cast主要用于类层次间的上行转换和下行转换。在类层次间进行上行转换时，dynamic_cast和static_cast的效果是一样的；在进行下行转换时，dynamic_cast具有类型检查的功能，比static_cast更安全。</li>
</ul>
<h4 id="c-sizeof">C++ 空类型的 sizeof</h4>
<ol>
<li>当定义一个空的类型，没有任何成员变量或者成员函数，对该类型求 sizeof ，得到的结果为 1 ，原因是当我们声明该类型实例的时候，它都必须在内存中占有一定的空间，至于占多少空间，由编译器决定，VS 中每个空类型的实例要占用 1 个字节的空间。</li>
<li>在上述类型中添加一个析构函数和一个构造函数，则再求 sizeof 的结果是 1 ，原因是调用析构函数和构造函数只需要知道函数的地址即可，而这些函数的地址只与其类型相关，而与类型的实例无关。</li>
<li>如果把析构函数标记为虚函数，则求 sizeof ，在 32 位机器上得到 4 ， 在 64 位机器上得到的是  8 。原因是，编译器一旦发现一个类型中有虚函数，就会为该类型生成一个 <strong>虚函数表</strong> ，并<strong>在该类型的每一个实例中添加一个指向虚函数表的指针</strong>。</li>
</ol>
<h4 id="c">C++ 拷贝构造函数定义</h4>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 编译出错，实参到形参的传值又会调用拷贝构造函数，形成递归调用</span>
  <span class="n">A</span><span class="p">(</span><span class="n">A</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 正确的拷贝构造函数</span>
  <span class="n">A</span><span class="p">(</span><span class="k">const</span> <span class="n">A</span> <span class="o">&amp;</span><span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">value</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<h4 id="1">面试题1：赋值运算符的实现</h4>
<div class="hlcode"><pre><span class="c1">// 题目：如下为类型 CMyString 的声明，请为该类型添加赋值运算符函数</span>
<span class="k">class</span> <span class="nc">CMyString</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="n">CMyString</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">pData</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
  <span class="n">CMyString</span><span class="p">(</span><span class="k">const</span> <span class="n">CMyString</span> <span class="o">&amp;</span><span class="n">str</span><span class="p">);</span>
  <span class="o">~</span><span class="n">CMyString</span><span class="p">();</span>

  <span class="n">CMyString</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">CMyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">Print</span><span class="p">();</span>

 <span class="nl">private:</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">m_pData</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>实现赋值运算符函数要注意：</p>
<ul>
<li>是否把返回值类型声明为该类型的引用，且返回值应该为 <code>*this</code>。只有返回引用才能实现<strong>连续赋值</strong>。</li>
<li>传入参数应该为常量引用（<code>const CMyString&amp;</code>）。</li>
<li>是否<strong>释放实例自身原有内存</strong>，防止内存泄漏。</li>
<li>是否判断传入的实例和当前实例（*this）是否为同一个实例，即处理<strong>“自赋值”</strong>的情况。如果是自赋值，不必进行操作，直接返回。</li>
<li>构造 Unit Tests 验证实现（如连续赋值、自赋值的情况）</li>
<li>可以利用 swap trick：</li>
</ul>
<div class="hlcode"><pre><span class="c1">// 实现赋值运算符函数</span>
<span class="c1">// 利用局部变量自动释放原有内存</span>
<span class="n">CMyString</span><span class="o">&amp;</span> <span class="n">CMyString</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">CMyString</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">str</span> <span class="o">!=</span> <span class="k">this</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CMyString</span> <span class="n">strTmp</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="c1">// 与临时变量交换成员指针，这样 strTmp 析构时自动释放原有内容的内存</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">pTmp</span> <span class="o">=</span> <span class="n">strTmp</span><span class="p">.</span><span class="n">m_pData</span><span class="p">;</span>
    <span class="n">strTmp</span><span class="p">.</span><span class="n">m_pData</span> <span class="o">=</span> <span class="n">m_pData</span><span class="p">;</span>
    <span class="n">m_pData</span> <span class="o">=</span> <span class="n">pTmp</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="2">面试题2：单例模式的实现</h4>
<p>Singleton 模式，实现一个只能生成一个实例的类。</p>
<p>设计模式经典 GoF 定义的单例模式需要满足以下两个条件：</p>
<ul>
<li>保证一个类只创建一个实例。</li>
<li>提供对该实例的全局访问点。</li>
</ul>
<p>如果系统有类似的实体（有且只有一个，且需要全局访问），那么就可以将其实现为一个单例。实际工作中常见的应用举例：</p>
<ul>
<li>日志类，一个应用往往只对应一个日志实例。</li>
<li>配置类，应用的配置集中管理，并提供全局访问。</li>
<li>管理器，比如windows系统的任务管理器就是一个例子，总是只有一个管理器的实例。</li>
<li>共享资源类，加载资源需要较长时间，使用单例可以避免重复加载资源，并被多个地方共享访问。</li>
</ul>
<h5 id="lazy-singleton">Lazy Singleton</h5>
<p>Lazy initialization，要用到时才分配资源</p>
<ul>
<li>将构造函数被声明为私有方法，这样从根本上杜绝外部使用构造函数生成新的实例，同时禁用拷贝函数与赋值操作符（声明为私有但是不提供实现）避免通过拷贝函数或赋值操作生成新实例。</li>
<li>提供静态方法Instance()作为实例全局访问点，该方法中先判断有没有现成的实例，如果有直接返回，如果没有则生成新实例并把实例的指针保存到私有的静态属性中。</li>
<li>Instance()返回的实例的引用而不是指针，如果返回的是指针可能会有被外部调用者delete掉的隐患，所以这里返回引用会更加保险一些。并且直到Instance()被访问，才会生成实例，这种特性被称为延迟初始化（Lazy initialization），这在一些初始化时消耗较大的情况有很大优势。</li>
<li>考虑线程安全，需要加锁，如 DCL（double-checked locking）。</li>
</ul>
<h5 id="eager-singleton">Eager Singleton</h5>
<ul>
<li>这种实现在程序开始(静态属性instance初始化)的时就完成了实例的创建。这正好和上述的Lazy Singleton相反。</li>
<li>由于在main函数之前初始化，所以没有线程安全的问题，但是潜在问题在于 no-local static 对象（函数外的static对象）在不同编译单元（可理解为cpp文件和其包含的头文件）中的初始化顺序是未定义的。如果在初始化完成之前调用 Instance()方法会返回一个未定义的实例。</li>
</ul>
<h5 id="meyers-singleton">Meyers Singleton</h5>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Singleton</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">static</span> <span class="n">Singleton</span><span class="o">&amp;</span> <span class="n">Instance</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static</span> <span class="n">Singleton</span> <span class="n">instance_</span><span class="p">;</span>  <span class="c1">// 使用 local static 对象</span>
    <span class="k">return</span> <span class="n">instance_</span><span class="p">;</span>
  <span class="p">}</span>

 <span class="nl">private:</span>
  <span class="c1">// 构造函数声明为私有，防止外部显式构造新实例</span>
  <span class="n">Singleton</span><span class="p">()</span>   <span class="p">{</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Singleton 类构造函数&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">Singleton</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// 防止外部对单例指针进行 delete 操作</span>

  <span class="c1">// 下面两个函数不提供实现，防止显式调用</span>
  <span class="n">Singleton</span><span class="p">(</span><span class="k">const</span> <span class="n">Singleton</span><span class="o">&amp;</span><span class="p">);</span>
  <span class="n">Singleton</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Singleton</span><span class="o">&amp;</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>


<p>Scott Meyers在《Effective C++》（Item 04）中的提出另一种更优雅的单例模式实现，使用local static对象（函数内的static对象）。当第一次访问Instance()方法时才创建实例。</p>
<ul>
<li>单线程下，正确。</li>
<li>C++11及以后的版本（如C++14）的多线程下，正确。G++4.0及以上是支持的。</li>
<li>C++11之前的多线程下，不一定正确。</li>
</ul>
<h4 id="3">面试题3：二维数组中的查找</h4>
<blockquote>
<p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
</blockquote>
<p>就是 leetcode 的一道题： https://leetcode.com/problems/search-a-2d-matrix-ii/</p>
<p>第一种解法，分治+二分查找。时间复杂度 O(m * log(n))，m 为矩阵行数，n 为矩阵列数。</p>
<p>第二种解法，时间复杂度 O(m + n)，从矩阵右上角开始向左或下进行搜索。以矩阵右上角元素为根节点，想象为一棵 BST（Binary Search Tree）。</p>
<p>第二种解法如何想到？从一个“角”上开始查找，利用矩阵本身的性质。本题除了从右上角出发，也可以从左下角出发，但左上角和右下角不行。</p>
<p>单测构造：</p>
<ul>
<li>二维数组中包含要查找的数字</li>
<li>二维数组中不包含要查找的数字</li>
<li>异常输入值（空指针）</li>
</ul>
<h4 id="c_1">C 语言风格字符串</h4>
<div class="hlcode"><pre><span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>
<span class="n">strcpy</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="s">&quot;0123456789&quot;</span><span class="p">);</span>  <span class="c1">// 错误，&quot;0123456789&quot; 实际长度为 11，末尾有 &#39;\0&#39;</span>
</pre></div>


<h4 id="4">面试题4：替换空格</h4>
<blockquote>
<p>设计一种方法，将一个字符串中的所有空格替换成 %20 。你可以假设该字符串有足够的空间来加入新的字符，且你得到的是“真实的”字符长度。<br />
对于字符串"Mr John Smith", 长度为 13，替换空格之后的结果为"Mr%20John%20Smith"</p>
</blockquote>
<p>分析：字符串就是数组，如果允许另开一个数组，从前向后替换很容易写出 O(n) 的算法。如果不允许开新数组，那么从前向后替换的时间复杂度为 O(n^2)，因为每替换一次后面的字符都要移动。如果从后向前进行替换（设置两个指针，一个指向原字符串末尾，一个指向替换后的新字符串末尾），则可以实现每个字符只移动一次，这样时间复杂度仍为 O(n)，不过需要先扫描一遍原字符串并计算新字符串的长度。</p>
<h4 id="_3">链表</h4>
<p>动态数据结构，插入、删除节点效率高；不支持随机存取，查找效率低。</p>
<div class="hlcode"><pre><span class="k">struct</span> <span class="n">ListNode</span> <span class="p">{</span>
  <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">v_</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">v_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">next</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 向链表中添加节点</span>
<span class="kt">void</span> <span class="nf">add_node_list</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*&amp;</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">//...</span>
<span class="p">}</span>
</pre></div>


<p>注意向链表中插入节点的函数，函数参数中头指针要用 ListNode<em>&amp; 或者 ListNode</em>* 类型。向一个空链表中插入一个节点时，新插入的节点就是链表的头指针，由于此时会改动头指针，必须用指针引用或二级指针，否则除了这个函数后 head 仍将为 NULL。</p>
<h4 id="5">面试题5：从尾到头打印链表</h4>
<p>如果允许修改链表 ==&gt; 链表逆序。</p>
<p>不允许修改链表，使用栈或者递归。</p>
<div class="hlcode"><pre><span class="k">struct</span> <span class="n">ListNode</span> <span class="p">{</span>
  <span class="n">ListNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">v_</span><span class="p">)</span> <span class="o">:</span> <span class="n">val</span><span class="p">(</span><span class="n">v_</span><span class="p">),</span> <span class="n">next</span><span class="p">(</span><span class="nb">NULL</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">int</span> <span class="n">val</span><span class="p">;</span>
  <span class="n">ListNode</span> <span class="o">*</span><span class="n">next</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 递归实现逆序打印链表</span>
<span class="kt">void</span> <span class="nf">print_list_reverse_r</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">print_list_reverse_r</span><span class="p">(</span><span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">);</span>
  <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="6">面试题6：重建二叉树</h4>
<p>给出一棵二叉树的“先序+中序”遍历或者“中序+后序”遍历，重建这棵树。</p>
<p>这题不知道做过几遍了，以先序为例，<strong>先序中第一个节点一定是整棵树的根节点</strong>，找到根节点在中序遍历中的位置，这样就得到了根节点的左右子树，然后递归去处理即可。</p>
<p>测试用例的设计：</p>
<ul>
<li>普通二叉树（完全二叉树、不完全二叉树）</li>
<li>特殊二叉树（所有节点都没有右子树，所有节点都没有左子树，只有一个节点）</li>
<li>特殊情况（输入 NULL，输入的先序序列与中序序列不匹配）</li>
</ul>
<h4 id="7">面试题7：用两个栈实现一个队列</h4>
<p>push 操作永远向 stack1 中添加元素；pop 操作永远从 stack2 中取出元素，当 stack2 为空时，将 stack1 中所有元素 pop 进 stack2 后再从 stack2 取出元素。</p>
<h4 id="7-2">面试题7-2：用两个队列实现一个栈</h4>
<p>方法：用一个队列为主队列，一个队列为辅助队列存放临时元素。</p>
<ul>
<li>入栈：将元素依次压入主队列</li>
<li>出栈：先将拥有n个元素的主队列的其中的n-1个元素倒入辅助队列，然后将原主队列的最后剩下的一个元素弹出队列，相当于出栈，这个时候，辅助队列和主队列进行交换，继续进行刚才的出栈操作。</li>
</ul>
<h4 id="_4">查找与排序</h4>
<ul>
<li>二分查找，要求有序</li>
<li>哈希表，O(1) 时间，但需要额外空间</li>
<li>Binary Search Tree，如何建立、如何插入节点</li>
</ul>
<p>排序，各种排序的特点，快速排序的实现等。平均时间复杂度、最坏时间复杂度等都要掌握。</p>
<p>例子，数组本身已经排好序了，而每一轮排序时都以最后一个元素为 pivot ，此时快速排序时间复杂度为 O(n^2)</p>
<p>例子2：</p>
<blockquote>
<p>Q: 请实现一个排序算法，时间复杂度要求 O(n)</p>
<p>A: 排序的对象是什么？</p>
<p>Q: 数字，要求对所有员工的年龄排序。</p>
<p>A: 能否使用辅助空间？</p>
<p>Q: 可以，不能超过 O(n)</p>
</blockquote>
<p>学会提问，了解问题的背景、细节。 O(n) 说明只能扫描一遍数组，利用计数排序，开一个数组记录每个年龄出现的次数（假设年龄范围 0 到 99）。</p>
<h4 id="8">面试题8：旋转数组中的最小元素</h4>
<p>旋转数组：数组 {1, 2, 3, 4, 5, 6, 7, 8} right rotate 3 位后得到 {6, 7, 8, 1, 2, 3, 4, 5}</p>
<blockquote>
<p>输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。</p>
</blockquote>
<p>O(n) 复杂度的解法肯定是不行的，要求 O(lg n)</p>
<p>如果没有重复元素，直接利用二分思想。如果 <code>nums[left] &lt; nums[mid]</code> ，说明 rotate 前的首元素在右半段，否则在左半段；终止条件是左右两个指针相邻，返回小的那个。</p>
<p>有重复元素的时候，二分会有问题：</p>
<p>{2, 2, 2, 2, 2, 2, 2, 2, 0, 1, 1, 2} 和 {2, 2, 2, 0, 2, 2, 2, 2, 2, 2, 2, 2}， 我们发现，当第一个数字和最后一个数字，还有中间那个数字全部相等的时候，二分查找法就崩溃了，因为它无法判断到底该去左半边还是右半边。这种情况下，我们将左指针右移一位，略过一个相同数字，这对结果不会产生影响，因为我们只是去掉了一个相同的，然后对剩余的部分继续用二分查找法，在最坏的情况下，比如数组所有元素都相同，时间复杂度会升到O(n)。</p>
<h4 id="9">面试题9：斐波那契数列</h4>
<p>直接用递归效率太低；利用循环+缓存，时间复杂度 O(n)。</p>
<p>实际上利用数学公式，还有 O(log(n)) 的方法：</p>
<p>\begin{equation}<br />
\begin{bmatrix}<br />
f(n) &amp; f(n-1) \\<br />
f(n-1) &amp; f(n-2)<br />
\end{bmatrix}<br />
=<br />
\begin{bmatrix}<br />
1 &amp; 1 \\<br />
1 &amp; 0<br />
\end{bmatrix} ^{n-1}<br />
\end{equation}</p>
<p>这样转化为求一个矩阵的 n 次方问题：要求 n 次方，可以先求 n/2 次方，于是可以利用递归。</p>
<h4 id="_5">变态跳台阶</h4>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p>
</blockquote>
<p>就是求斐波那契数列。</p>
<blockquote>
<p>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</p>
</blockquote>
<p>要么直接跳到 n 级，要么从其他级跳过来，因此：</p>
<p>f(n) = f(n-1) + f(n-2) + ... + f(1) + 1</p>
<p>f(n-1) = f(n-2) + f(n-3) + ... + f(1) + 1</p>
<p>注意，将第二个式子代回第一个，有 f(n) = 2*f(n-1)</p>
<p>于是 f(n) = 2^(n-1)</p>
<h4 id="10-1">面试题10：二进制中 1 的个数</h4>
<blockquote>
<p>输入一个 10 进制整数，输出其二进制表示中 1 的个数。</p>
</blockquote>
<p>先判断整数的二进制表示中最右边一位是不是 1 。接着把输入的整数右移一位，再判断最右边一位是不是 1。这样每次移动一位，直到整个整数变成 0 为止。如何判断最右边一位是不是 1？与整数 1 进行与运算：</p>
<div class="hlcode"><pre><span class="kt">int</span> <span class="nf">count_binary_ones</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">num</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">num</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个时间复杂度是 O(lg n)，n 是整数大小，因为把整数右移 1 位和把整数除以 2 是等价的。</p>
<p>上面代码还有问题。如果输入的整数为负数怎么办？负数的最高位为1，右移后最高位仍为 1，但如果一直做右移运算，最终数字会变成 0xFFFFFFFF 而陷入死循环。</p>
<p>这里介绍一个性质，任意整数 n，n 与 (n - 1) 进行与操作可以将 n 的二进制的最右边一个 1（不一定是最右边一位）变为 0。<br />
（把一个整数减去 1，再和原整数做与运算，会把该整数最右边一个 1 变成 0。）</p>
<p>利用这个性质可以解决这一题：</p>
<div class="hlcode"><pre><span class="kt">int</span> <span class="nf">count_binary_ones</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">cnt</span><span class="p">;</span>
    <span class="n">num</span> <span class="o">=</span> <span class="n">num</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">num</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">cnt</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>这个解法效率更高，因为循环次数只与 n 中 1 的实际个数有关。</p>
<p>二进制其他题目：</p>
<ul>
<li>用一条语句判断一个整数是不是 2 的整数次方。一个整数如果是 2 的整数次方，那么它的二进制表示中有且只有一位是 1，而其他所有位都是 0。利用 n &amp; (n-1)，如果结果为 0 说明 n 的二进制中只有一个 1。</li>
<li>输入两个整数 m 和 n，计算需要改变 m 的二进制表示中的多少位才能得到 n 。分两步：1) 求 m 与 n 的异或（异或结果中的 1 表示 m、n 对应位不同）；2) 统计异或结果中 1 的位数。</li>
</ul>
  <div class="relation">
    <h2>Related</h2>
    <ul>
    
    <li><a href="/wiki/job_interviews/jianzhi_offer_notes_6.html">剑指offer笔记(6)</a></li>
    
    <li><a href="/wiki/job_interviews/leetcode_solutions.html">LeetCode Solutions</a></li>
    
    <li><a href="/wiki/job_interviews/jianzhi_offer_notes_2.html">剑指offer笔记(2)</a></li>
    
    <li><a href="/wiki/job_interviews/jianzhi_offer_notes_3.html">剑指offer笔记(3)</a></li>
    
    <li><a href="/wiki/job_interviews/ctci_notes.html">< Cracking The Code Interview > notes</a></li>
    
    <li><a href="/wiki/job_interviews/jianzhi_offer_notes_4.html">剑指offer笔记(4)</a></li>
    
    <li><a href="/wiki/job_interviews/jianzhi_offer_notes_5.html">剑指offer笔记(5)</a></li>
    
    </ul>
  </div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 Yilin Gui.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-11-17 03:18:32</p>
      </span>
    </div>

    
    
  </body>
</html>