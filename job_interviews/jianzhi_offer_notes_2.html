<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>剑指offer笔记(2) - Yilin's Wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          <!--$表示行内元素，$$表示块状元素 -->
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <!--Mermaid流程图-->
    <script src="https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#job_interviews">job_interviews</a>&nbsp;&#187;&nbsp;剑指offer笔记(2)
    <span class="updated">Page Updated&nbsp;
      2019-07-13 01:34
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">剑指offer笔记(2)</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">第三章 高质量的代码</a><ul>
<li><a href="#11">面试题11：数值的整数次方</a></li>
<li><a href="#12-1-n">面试题12：打印 1 到最大的 n 位数</a></li>
<li><a href="#13-o1">面试题13：在 O(1) 时间删除链表节点</a></li>
<li><a href="#14">面试题14：奇偶分割数组</a></li>
<li><a href="#15-k">面试题15：链表中倒数第 k 个节点</a></li>
<li><a href="#16">面试题16：翻转链表</a></li>
<li><a href="#17">面试题17：合并两个有序链表</a></li>
<li><a href="#18">面试题18：树的子结构</a></li>
</ul>
</li>
</ul>
</div>
<p><a href="https://book.douban.com/subject/27008702/">《剑指Offer》</a> 读书笔记。</p>
<h2 id="_1">第三章 高质量的代码</h2>
<p>规范的代码：</p>
<ul>
<li>清晰的书写</li>
<li>清晰的布局</li>
<li>合理的命名</li>
</ul>
<p>代码的完整性：</p>
<ul>
<li>功能测试，注意一些功能要求中没有明说但可能隐含的情况（如大数运算，负数等）</li>
<li>边界测试，递归、循环的终止条件，输入极值等</li>
<li>负面测试，错误的输入</li>
</ul>
<p>错误处理方法：</p>
<ul>
<li>函数返回值</li>
<li>设置全局变量</li>
<li>异常</li>
</ul>
<h4 id="11">面试题11：数值的整数次方</h4>
<blockquote>
<p>实现 pow 函数，不需要考虑大数问题。</p>
</blockquote>
<p>Naive 的解法：</p>
<div class="hlcode"><pre><span class="kt">double</span> <span class="nf">Power</span><span class="p">(</span><span class="kt">double</span> <span class="n">base</span><span class="p">,</span> <span class="kt">int</span> <span class="n">exponent</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">exponent</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">result</span> <span class="o">*=</span> <span class="n">base</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>上面代码存在的问题：</p>
<ul>
<li>exponent 小于 1 时怎么办？</li>
</ul>
<p>当指数为负数时，可以先对指数求绝对值，然后算出次方的结果，再取倒数。既然有倒数，就要考虑有没有可能对 0 取倒数，如果出现对 0 取倒数（base 为 0 而 exponent 为 负）的情况，抛出异常。此外，还有一个边界条件是 base 和 exponent 都为 0，此时数学上无意义，向面试官说明即可。</p>
<p>上面的代码已经考虑的比较全面了，但还有一个问题：效率。</p>
<p>\begin{equation}<br />
a^n =<br />
\begin{cases}<br />
a^{n/2} * a^{n/2}, \quad \ &amp; n 为偶数, \\<br />
a^{(n-1)/2} * a^{(n-1)/2} * a, \quad \ \ &amp; n 为奇数,<br />
\end{cases}<br />
\end{equation}</p>
<div class="hlcode"><pre><span class="kt">double</span> <span class="nf">power_with_unsigned_exponent</span><span class="p">(</span><span class="kt">double</span> <span class="n">base</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">exponent</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="mf">1.0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span><span class="p">;</span>

    <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">power_with_unsigned_exponent</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">exponent</span> <span class="o">&gt;&gt;</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">result</span> <span class="o">*=</span> <span class="n">result</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">exponent</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">result</span> <span class="o">*=</span> <span class="n">base</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="12-1-n">面试题12：打印 1 到最大的 n 位数</h4>
<blockquote>
<p>输入数字 n，按顺序打印从 1 到最大的 n 位整数。<br />
例子，输入 3，打印从 1 到 999。</p>
</blockquote>
<p>陷阱：n 有可能非常大，需要考虑大数。</p>
<p>解法1：模拟大数自增运算。</p>
<p>解法2：把问题转换成数字排列，使用递归。</p>
<h4 id="13-o1">面试题13：在 O(1) 时间删除链表节点</h4>
<blockquote>
<p>给定一个单链表的头指针和一个节点指针，定义一个函数在 O(1) 时间删除该节点。</p>
</blockquote>
<p>要删除节点 i，需要从链表头节点开始遍历，找到节点 i 的前一个节点。这样的方法时间复杂度为 O(n)。</p>
<p>另一种方法：既然给出了要删除节点的指针，可以直接得到该节点的下一个节点，把下一个节点的内容复制到要删除的节点里覆盖掉原来的内容，删除下一个节点即可，这样时间复杂度为 O(1)。一个特殊情况，如果要删除的节点是尾节点，仍然需要从链表头开始遍历。因此该方法平均时间复杂度为 O(1)，最坏情况时间复杂度为 O(n)。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/**</span>
<span class="cm">     * @param node: a node in the list should be deleted</span>
<span class="cm">     * @return: 假设 node 非表头或表尾</span>
<span class="cm">     */</span>
    <span class="kt">void</span> <span class="n">deleteNode</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">node</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// write your code here</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">node</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">=</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">;</span>
        <span class="k">delete</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h4 id="14">面试题14：奇偶分割数组</h4>
<blockquote>
<p>分割一个整数数组，使得所有奇数在所有偶数前面。</p>
</blockquote>
<p>类似 std::partition()，注意是否要求 stable。</p>
<p>非 stable 版本（类似 quick sort）:</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">ReorderArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">array</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">l</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">r</span> <span class="o">=</span> <span class="n">array</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">l</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">while</span> <span class="p">(</span><span class="n">l</span> <span class="o">&lt;</span> <span class="n">r</span> <span class="o">&amp;&amp;</span> <span class="n">array</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">--</span><span class="n">r</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">swap</span><span class="p">(</span><span class="n">array</span><span class="p">[</span><span class="n">l</span><span class="p">],</span> <span class="n">array</span><span class="p">[</span><span class="n">r</span><span class="p">]);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>stable 版本：</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">ReorderArray</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">nums</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="n">nums</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&gt;</span> <span class="n">i</span><span class="p">;</span> <span class="o">--</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">swap</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="n">nums</span><span class="p">[</span><span class="n">j</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>stable 版本复杂度 O(n^2)，如果允许使用额外空间，可以做到 O(n)。</p>
<h4 id="15-k">面试题15：链表中倒数第 k 个节点</h4>
<p>为了得到第 k 个节点，最自然的想法是先走到链表的尾部，再从尾部回溯 k 步，然而单链表不允许回溯。</p>
<p>设置两个指针，第一个指针比第二个指针先走 k 步。当第一个指针走到尾部时，第二个指针指向的就是倒数第 k 个节点。</p>
<p>很容易写出以下代码：</p>
<div class="hlcode"><pre><span class="n">ListNode</span><span class="o">*</span> <span class="nf">find_kth_node</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">p2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p>上面的代码不鲁棒：</p>
<ul>
<li>输入的为空指针怎么办？</li>
<li>输入的 k 不大于 0 怎么办？</li>
<li>k 大于链表中节点总个数怎么办？</li>
</ul>
<p>考虑特殊情况后的代码：</p>
<div class="hlcode"><pre><span class="n">ListNode</span><span class="o">*</span> <span class="nf">find_kth_node</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p1</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">p2</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">p1</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">p1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">p1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="n">p2</span> <span class="o">=</span> <span class="n">p2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">p2</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h4 id="16">面试题16：翻转链表</h4>
<p>非常经典。先画一个只有 4 个节点的 list 模拟下，找出规律。</p>
<div class="hlcode"><pre><span class="n">class</span> <span class="n">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/**</span>
<span class="cm">     * @param head: The first node of linked list.</span>
<span class="cm">     * @return: The new head of reversed linked list.</span>
<span class="cm">     */</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">reverse</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">head</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// write your code here</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">head</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">head</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">head</span><span class="p">;</span>

        <span class="n">ListNode</span> <span class="o">*</span><span class="n">new_head</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">head</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ListNode</span> <span class="o">*</span><span class="n">t</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">new_head</span><span class="p">;</span>
            <span class="n">new_head</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">new_head</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>可能出错的情况：</p>
<ul>
<li>输入的链表头为 NULL 或者只有一个节点时</li>
<li>反转后的链表出现断裂</li>
<li>返回的翻转后的链表的头节点不是原链表的尾节点</li>
</ul>
<p>测试用例设计：</p>
<ul>
<li>输入的链表头为 NULL</li>
<li>输入的链表只有一个节点</li>
<li>输入的链表有多个节点</li>
</ul>
<h4 id="17">面试题17：合并两个有序链表</h4>
<p>考察基本功，可以用 dummy head 技巧简化选取头结点：</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/**</span>
<span class="cm">     * @param ListNode l1 is the head of the linked list</span>
<span class="cm">     * @param ListNode l2 is the head of the linked list</span>
<span class="cm">     * @return: ListNode head of linked list</span>
<span class="cm">     */</span>
    <span class="n">ListNode</span> <span class="o">*</span><span class="n">mergeTwoLists</span><span class="p">(</span><span class="n">ListNode</span> <span class="o">*</span><span class="n">l1</span><span class="p">,</span> <span class="n">ListNode</span> <span class="o">*</span><span class="n">l2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// write your code here</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l1</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">l2</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">l2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">l1</span><span class="p">;</span>

        <span class="n">ListNode</span> <span class="nf">dummy</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
        <span class="n">ListNode</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">dummy</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">l2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">l1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">&lt;</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span><span class="p">;</span>
                <span class="n">l1</span> <span class="o">=</span> <span class="n">l1</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span><span class="p">;</span>
                <span class="n">l2</span> <span class="o">=</span> <span class="n">l2</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">l1</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">l1</span><span class="p">;</span>
        <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">l2</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">next</span> <span class="o">=</span> <span class="n">l2</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">dummy</span><span class="p">.</span><span class="n">next</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h4 id="18">面试题18：树的子结构</h4>
<blockquote>
<p>输入两棵二叉树 A 和 B，判断 B 是否为 A 的子结构</p>
</blockquote>
<p>第一步在树 A 中找到和 B 的根节点的值一样的节点 R，第二步再判断树 A 中以 R 为根节点的子树是否包含和树 B 一样的结构。</p>
<p>下面是判断“子树”的解法：</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/**</span>
<span class="cm">     * @param T1, T2: The roots of binary tree.</span>
<span class="cm">     * @return: True if T2 is a subtree of T1, or false.</span>
<span class="cm">     */</span>
    <span class="kt">bool</span> <span class="n">isSubtree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">T1</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">T2</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// write your code here</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">T2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">==</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">is_same_tree</span><span class="p">(</span><span class="n">T1</span><span class="p">,</span> <span class="n">T2</span><span class="p">);</span>
            <span class="c1">// result = tree1_contains_tree2(T1, T2);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">isSubtree</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">T2</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">result</span><span class="p">)</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">isSubtree</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">T2</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="c1">// 相同子结构</span>
    <span class="kt">bool</span> <span class="n">tree1_contains_tree2</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">T1</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">T2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">T2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">return</span> <span class="nf">tree1_contains_tree2</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
            <span class="n">tree1_contains_tree2</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 相同子树</span>
    <span class="kt">bool</span> <span class="n">is_same_tree</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">T1</span><span class="p">,</span> <span class="n">TreeNode</span> <span class="o">*</span><span class="n">T2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">T2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">T1</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">T2</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">||</span>
            <span class="n">T1</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="n">T2</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">val</span> <span class="o">!=</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">val</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">return</span> <span class="nf">is_same_tree</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> 
            <span class="n">is_same_tree</span><span class="p">(</span><span class="n">T1</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">T2</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>
  <div class="relation">
    <h2>Related</h2>
    <ul>
    
    <li><a href="/wiki/job_interviews/jianzhi_offer_notes_6.html">剑指offer笔记(6)</a></li>
    
    <li><a href="/wiki/job_interviews/leetcode_solutions.html">LeetCode Solutions</a></li>
    
    <li><a href="/wiki/job_interviews/jianzhi_offer_notes_3.html">剑指offer笔记(3)</a></li>
    
    <li><a href="/wiki/job_interviews/ctci_notes.html">< Cracking The Code Interview > notes</a></li>
    
    <li><a href="/wiki/job_interviews/jianzhi_offer_notes_4.html">剑指offer笔记(4)</a></li>
    
    <li><a href="/wiki/job_interviews/jianzhi_offer_notes_5.html">剑指offer笔记(5)</a></li>
    
    <li><a href="/wiki/job_interviews/jianzhi_offer_notes_1.html">剑指offer笔记(1)</a></li>
    
    </ul>
  </div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 Yilin Gui.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-11-13 01:27:27</p>
      </span>
    </div>

    
    
  </body>
</html>