<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Baidu Apollo 感知红绿灯代码串讲 - Yilin's Wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          <!--$表示行内元素，$$表示块状元素 -->
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <!--Mermaid流程图-->
    <script src="https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#autonomous_driving">autonomous_driving</a>&nbsp;&#187;&nbsp;Baidu Apollo 感知红绿灯代码串讲
    <span class="updated">Page Updated&nbsp;
      2019-11-01 00:52
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">Baidu Apollo 感知红绿灯代码串讲</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#1-onboard">1 Onboard 部分</a></li>
<li><a href="#2">2 算法部分</a><ul>
<li><a href="#21-preprocessor">2.1 preprocessor</a></li>
<li><a href="#22-detectordetection">2.2 detector/detection</a></li>
<li><a href="#23-detectorrecognition">2.3 detector/recognition</a></li>
<li><a href="#24-tracker">2.4 tracker</a></li>
</ul>
</li>
</ul>
</div>
<p>Apollo 3.5 版本，代码地址：</p>
<p><a href="https://github.com/ApolloAuto/apollo/tree/r3.5.0/modules/perception/camera/lib/traffic_light/">apollo/modules/perception/camera/lib/traffic_light/</a>。</p>
<p>交通信号灯感知，使用摄像头获取当前车道对应红绿灯的状态。</p>
<p>支持的灯形：</p>
<p><img alt="" src="/wiki/attach/images/baidu_apollo_trafficlights_codes_reading/detect_box_types.png" /></p>
<p>支持的颜色：</p>
<ul>
<li>红</li>
<li>绿</li>
<li>黄</li>
<li>黑</li>
</ul>
<p>使用长焦、短焦两个相机：</p>
<ul>
<li>长焦相机(12mm焦距)：观察前方远距离的信号灯，视野较小；</li>
<li>短焦相机(6mm焦距)：视野较大，观察近处信号灯。</li>
</ul>
<p>输入：</p>
<ul>
<li>相机图像 channel</li>
<li>相机参数（内外参）</li>
<li>HDMap</li>
<li>无人车定位</li>
<li>V2X 红绿灯结果</li>
</ul>
<p>输出：</p>
<ul>
<li>{ Timestamp, {Signal ID, Detected BBox, Signal Color} }</li>
</ul>
<h2 id="1-onboard">1 Onboard 部分</h2>
<div class="hlcode"><pre><span></span><span class="n">modules</span><span class="o">/</span><span class="n">perception</span><span class="o">/</span><span class="n">onboard</span><span class="o">/</span><span class="n">component</span><span class="o">/</span><span class="n">trafficlights_perception_component</span>.<span class="n">h</span>
<span class="n">modules</span><span class="o">/</span><span class="n">perception</span><span class="o">/</span><span class="n">onboard</span><span class="o">/</span><span class="n">component</span><span class="o">/</span><span class="n">trafficlights_perception_component</span>.<span class="n">cc</span>
</pre></div>


<p><code>TrafficLightsPerceptionComponent</code>: 红绿灯模块对应的 CyberRT 组件</p>
<p>对应 dag 文件：</p>
<p>modules/perception/production/dag/dag_streaming_perception_trafficlights.dag</p>
<div class="hlcode"><pre><span></span><span class="n">module_config</span> {
  <span class="n">module_library</span> : <span class="s">&quot;/apollo/bazel-bin/modules/perception/onboard/component/libperception_component_camera.so&quot;</span>
  <span class="n">components</span> {
    <span class="n">class_name</span> : <span class="s">&quot;TrafficLightsPerceptionComponent&quot;</span>
    <span class="n">config</span> {
      <span class="n">name:</span> <span class="s">&quot;TrafficLightsComponent&quot;</span>
      <span class="n">config_file_path:</span> <span class="s">&quot;/apollo/modules/perception/production/conf/perception/camera/trafficlights_perception_component.config&quot;</span>
      <span class="n">flag_file_path:</span> <span class="s">&quot;/apollo/modules/perception/production/conf/perception/perception_common.flag&quot;</span>
      <span class="n">readers</span> {
          <span class="n">channel:</span> <span class="s">&quot;/apollo/perception/traffic_light_status&quot;</span>
      }
    }
  }
}
</pre></div>


<p>处理入口函数：</p>
<div class="hlcode"><pre><span></span><span class="kt">void</span> <span class="n">TrafficLightsPerceptionComponent</span><span class="o">::</span><span class="n">OnReceiveImage</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">apollo</span><span class="o">::</span><span class="n">drivers</span><span class="o">::</span><span class="n">Image</span><span class="o">&gt;</span> <span class="n">msg</span><span class="p">,</span>  <span class="c1">// 图像消息</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">camera_name</span>  <span class="c1">// 相机名</span>
    <span class="p">);</span>
</pre></div>


<p>这是一个回调(callback)函数，当接收到对应相机的图像消息时自动调用。</p>
<p><code>OnReceiveImage()</code> 主要处理流程：</p>
<div class="hlcode"><pre><span></span><span class="mi">1</span><span class="p">.</span> <span class="err">投影选相机</span>

<span class="err">查询定位和地图信号灯信息，根据信号灯在图像平面上的投影情况选择用于检测红绿灯的相机，保存相机选择结果。</span>

<span class="mi">2</span><span class="p">.</span> <span class="err">判断当前图像时间戳和上一次处理时间戳间隔，若间隔过小，跳过</span>

<span class="err">这一步是为了降低实际检测的处理频率，红绿灯检测不需要很高的帧率</span>

<span class="mi">3</span><span class="p">.</span> <span class="err">同步当前图像和相机选择结果</span>

<span class="err">判断当前图像是否来自于要用于检测红绿灯的相机。如果不是则直接返回，不用继续处理当前图像；如果是则继续进行下一步。</span>

<span class="mi">4</span><span class="p">.</span> <span class="err">调用红绿灯检测算法模块，给出红绿灯识别结果</span>

<span class="o">-</span> <span class="n">Detect</span><span class="p">:</span> <span class="err">检测，根据地图红绿灯投影在</span> <span class="n">Crop</span> <span class="n">ROI</span> <span class="err">中检测红绿灯</span> <span class="mi">2</span><span class="n">D</span> <span class="err">框</span>
<span class="o">-</span> <span class="n">Recognize</span><span class="p">:</span> <span class="err">识别，对检测出的红绿灯</span> <span class="mi">2</span><span class="n">D</span> <span class="err">框内容进行分类（红、绿、黑、黄）</span>
<span class="o">-</span> <span class="n">Revise</span><span class="p">:</span> <span class="err">修正，处理可能出现的漏检</span><span class="p">(</span><span class="k">Unknown</span><span class="p">)</span><span class="err">、误识别情况</span>

<span class="mi">5</span><span class="p">.</span> <span class="err">同步感知红绿灯识别结果和</span> <span class="n">V2X</span> <span class="err">红绿灯结果，输出。</span>
</pre></div>


<p>相关代码：</p>
<div class="hlcode"><pre><span></span><span class="kt">void</span> <span class="n">TrafficLightsPerceptionComponent</span><span class="o">::</span><span class="n">OnReceiveImage</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">apollo</span><span class="o">::</span><span class="n">drivers</span><span class="o">::</span><span class="n">Image</span><span class="o">&gt;</span> <span class="n">msg</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">camera_name</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>

  <span class="c1">// ...</span>

  <span class="n">camera</span><span class="o">::</span><span class="n">TLPreprocessorOption</span> <span class="n">preprocess_option</span><span class="p">;</span>
  <span class="n">preprocess_option</span><span class="p">.</span><span class="n">image_borders_size</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">image_border_sizes_</span><span class="p">;</span>

  <span class="c1">// 1. 投影选相机</span>
  <span class="c1">// UpdateCameraSelection() 实现了根据信号灯投影选择相机的功能</span>
  <span class="c1">// query pose and signals, add cached camera selection by lights&#39; projections</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">UpdateCameraSelection</span><span class="p">(</span><span class="n">image_msg_ts</span><span class="p">,</span> <span class="n">preprocess_option</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame_</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">AWARN</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;add_cached_camera_selection failed, ts: &quot;</span>
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">image_msg_ts</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">update_camera_selection_time</span> <span class="o">=</span>
      <span class="n">PERCEPTION_PERF_BLOCK_END_WITH_INDICATOR</span><span class="p">(</span><span class="n">perf_indicator</span><span class="p">,</span>
                                               <span class="s">&quot;UpdateCameraSelection&quot;</span><span class="p">);</span>

  <span class="c1">// 2. 判断当前图像时间戳和上一次处理时间戳间隔，若间隔过小，跳过</span>
  <span class="c1">// skipping frame according to last proc image timestamp</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">last_proc_image_ts_</span> <span class="o">&gt;</span> <span class="mf">0.0</span> <span class="o">&amp;&amp;</span>
      <span class="n">receive_img_timestamp</span> <span class="o">-</span> <span class="n">last_proc_image_ts_</span> <span class="o">&lt;</span> <span class="n">proc_interval_seconds_</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 3. 同步当前图像和相机选择结果</span>
  <span class="c1">// sync image with cached projections</span>
  <span class="kt">bool</span> <span class="n">sync_image_ok</span> <span class="o">=</span>
      <span class="n">preprocessor_</span><span class="o">-&gt;</span><span class="n">SyncInformation</span><span class="p">(</span><span class="n">image_msg_ts</span><span class="p">,</span> <span class="n">camera_name</span><span class="p">);</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">sync_information_time</span> <span class="o">=</span> <span class="n">PERCEPTION_PERF_BLOCK_END_WITH_INDICATOR</span><span class="p">(</span>
      <span class="n">perf_indicator</span><span class="p">,</span> <span class="s">&quot;SyncInformation&quot;</span><span class="p">);</span>
  <span class="c1">// 当前图像不是来自于要选用的相机，直接返回，不需要进行后续的检测、识别</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sync_image_ok</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>

  <span class="c1">// 由于存在跳帧策略，选相机时查 pose 的时间和当前图像的时间可能不同步，再查一次 pose 进行投影</span>
  <span class="c1">// 确保得到的投影准确</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">VerifyLightsProjection</span><span class="p">(</span><span class="n">image_msg_ts</span><span class="p">,</span> <span class="n">preprocess_option</span><span class="p">,</span> <span class="n">camera_name</span><span class="p">,</span>
                              <span class="o">&amp;</span><span class="n">frame_</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;VerifyLightsProjection on image failed, ts: &quot;</span>
          <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">image_msg_ts</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;, camera_name: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">camera_name</span>
          <span class="o">&lt;&lt;</span> <span class="s">&quot; last_query_tf_ts_: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">last_query_tf_ts_</span><span class="p">)</span>
          <span class="o">&lt;&lt;</span> <span class="s">&quot; need update_camera_selection immediately,&quot;</span>
          <span class="o">&lt;&lt;</span> <span class="s">&quot; reset last_query_tf_ts_ to -1&quot;</span><span class="p">;</span>
    <span class="n">last_query_tf_ts_</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 4. 调用红绿灯检测算法模块，给出红绿灯识别结果</span>
  <span class="n">traffic_light_pipeline_</span><span class="o">-&gt;</span><span class="n">Perception</span><span class="p">(</span><span class="n">camera_perception_options_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">frame_</span><span class="p">);</span>

  <span class="c1">// 5. 同步感知红绿灯识别结果和 V2X 红绿灯结果</span>
  <span class="n">SyncV2XTrafficLights</span><span class="p">(</span><span class="o">&amp;</span><span class="n">frame_</span><span class="p">);</span>

  <span class="c1">// 发送结果消息</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// V2X 红绿灯消息回调函数</span>
<span class="kt">void</span> <span class="n">TrafficLightsPerceptionComponent</span><span class="o">::</span><span class="n">OnReceiveV2XMsg</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">apollo</span><span class="o">::</span><span class="n">v2x</span><span class="o">::</span><span class="n">IntersectionTrafficLightData</span><span class="o">&gt;</span> <span class="n">v2x_msg</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">lck</span><span class="p">(</span><span class="n">mutex_</span><span class="p">);</span>
  <span class="n">v2x_msg_buffer_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="o">*</span><span class="n">v2x_msg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TrafficLightsPerceptionComponent</span><span class="o">::</span><span class="n">SyncV2XTrafficLights</span><span class="p">(</span>
    <span class="n">camera</span><span class="o">::</span><span class="n">CameraFrame</span><span class="o">*</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="n">camera_frame_timestamp</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">sync_single_light</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="p">](</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span> <span class="n">light</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">itr</span> <span class="o">=</span> <span class="n">v2x_msg_buffer_</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span> <span class="n">itr</span> <span class="o">!=</span> <span class="n">v2x_msg_buffer_</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span>
         <span class="o">++</span><span class="n">itr</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">double</span> <span class="n">v2x_timestamp</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">).</span><span class="n">header</span><span class="p">().</span><span class="n">timestamp_sec</span><span class="p">();</span>
      <span class="c1">// 从 V2X 消息缓存中找到时间戳足够接近的一帧</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">fabs</span><span class="p">(</span><span class="n">camera_frame_timestamp</span> <span class="o">-</span> <span class="n">v2x_timestamp</span><span class="p">)</span> <span class="o">&lt;</span>
          <span class="n">v2x_sync_interval_seconds_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">v2x_lights_num</span> <span class="o">=</span>
            <span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">).</span><span class="n">current_lane_trafficlight</span><span class="p">().</span><span class="n">single_traffic_light_size</span><span class="p">();</span>
        <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">v2x_lights</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">itr</span><span class="p">).</span><span class="n">current_lane_trafficlight</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v2x_lights_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">v2x_light</span> <span class="o">=</span> <span class="n">v2x_lights</span><span class="p">.</span><span class="n">single_traffic_light</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
          <span class="c1">// 利用 Signal ID 进行对应</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">light</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">!=</span> <span class="n">v2x_light</span><span class="p">.</span><span class="n">id</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span> <span class="n">v2x_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_UNKNOWN_COLOR</span><span class="p">;</span>
          <span class="kt">bool</span> <span class="n">blink</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
          <span class="k">switch</span> <span class="p">(</span><span class="n">v2x_light</span><span class="p">.</span><span class="n">color</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">default</span><span class="o">:</span>
            <span class="k">case</span> <span class="n">apollo</span><span class="o">::</span><span class="n">v2x</span><span class="o">::</span><span class="n">SingleTrafficLight</span><span class="o">::</span><span class="nl">UNKNOWN</span><span class="p">:</span>
              <span class="n">v2x_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_UNKNOWN_COLOR</span><span class="p">;</span>
              <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">apollo</span><span class="o">::</span><span class="n">v2x</span><span class="o">::</span><span class="n">SingleTrafficLight</span><span class="o">::</span><span class="nl">RED</span><span class="p">:</span>
              <span class="n">v2x_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_RED</span><span class="p">;</span>
              <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">apollo</span><span class="o">::</span><span class="n">v2x</span><span class="o">::</span><span class="n">SingleTrafficLight</span><span class="o">::</span><span class="nl">YELLOW</span><span class="p">:</span>
              <span class="n">v2x_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_YELLOW</span><span class="p">;</span>
              <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">apollo</span><span class="o">::</span><span class="n">v2x</span><span class="o">::</span><span class="n">SingleTrafficLight</span><span class="o">::</span><span class="nl">GREEN</span><span class="p">:</span>
              <span class="n">v2x_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_GREEN</span><span class="p">;</span>
              <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">apollo</span><span class="o">::</span><span class="n">v2x</span><span class="o">::</span><span class="n">SingleTrafficLight</span><span class="o">::</span><span class="nl">BLACK</span><span class="p">:</span>
              <span class="n">v2x_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_BLACK</span><span class="p">;</span>
              <span class="k">break</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">apollo</span><span class="o">::</span><span class="n">v2x</span><span class="o">::</span><span class="n">SingleTrafficLight</span><span class="o">::</span><span class="nl">FLASH_GREEN</span><span class="p">:</span>
              <span class="n">v2x_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_GREEN</span><span class="p">;</span>
              <span class="n">blink</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
              <span class="k">break</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="c1">// 完全相信 V2X 的结果</span>
          <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Sync V2X success. update color from &quot;</span>
                <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">light</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">color</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; to &quot;</span>
                <span class="o">&lt;&lt;</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v2x_color</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;; signal id: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">light</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
          <span class="n">light</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">v2x_color</span><span class="p">;</span>
          <span class="n">light</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">blink</span> <span class="o">=</span> <span class="n">blink</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">light</span> <span class="p">:</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">traffic_lights</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">sync_single_light</span><span class="p">(</span><span class="n">light</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<hr />
<h2 id="2">2 算法部分</h2>
<div class="hlcode"><pre><span></span><span class="n">modules</span><span class="o">/</span><span class="n">perception</span><span class="o">/</span><span class="n">camera</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">traffic_light</span>
  ├── <span class="n">preprocessor</span>
  └── <span class="n">detector</span>
        └── <span class="n">detection</span>
        └── <span class="n">recognition</span>
  └── <span class="n">tracker</span>
</pre></div>


<h3 id="21-preprocessor">2.1 preprocessor</h3>
<p>预处理，主要完成的任务是通过投影地图信号灯到图像平面来选择相机。</p>
<div class="hlcode"><pre><span></span><span class="n">preprocessor</span><span class="o">/</span>
  <span class="err">├──</span> <span class="n">tl_preprocess</span><span class="p">.</span><span class="n">proto</span>          <span class="o">#</span> <span class="err">配置定义</span>
  <span class="err">├──</span> <span class="n">tl_preprocessor</span><span class="p">.</span><span class="n">cc</span>
  <span class="err">├──</span> <span class="n">tl_preprocessor</span><span class="p">.</span><span class="n">h</span>            <span class="o">#</span> <span class="err">投影选相机预处理</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="err">├──</span> <span class="n">pose</span><span class="p">.</span><span class="n">cc</span>
  <span class="err">├──</span> <span class="n">pose</span><span class="p">.</span><span class="n">h</span>                       <span class="o">#</span> <span class="err">主车和相机</span> <span class="n">Pose</span> <span class="err">封装</span>
  <span class="err">├──</span> <span class="n">multi_camera_projection</span><span class="p">.</span><span class="n">cc</span>
  <span class="err">└──</span> <span class="n">multi_camera_projection</span><span class="p">.</span><span class="n">h</span>    <span class="o">#</span> <span class="err">多相机投影</span>
</pre></div>


<p><code>tl_preprocessor.cc</code> 主要函数介绍：</p>
<div class="hlcode"><pre><span></span><span class="c1">// 投影选相机</span>
<span class="kt">bool</span> <span class="n">TLPreprocessor</span><span class="o">::</span><span class="n">UpdateCameraSelection</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">CarPose</span> <span class="o">&amp;</span><span class="n">pose</span><span class="p">,</span> <span class="k">const</span> <span class="n">TLPreprocessorOption</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">lights</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">timestamp</span> <span class="o">=</span> <span class="n">pose</span><span class="p">.</span><span class="n">getTimestamp</span><span class="p">();</span>
  <span class="n">selected_camera_name_</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">timestamp</span><span class="p">;</span>
  <span class="n">selected_camera_name_</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">GetMaxFocalLenWorkingCameraName</span><span class="p">();</span>
  <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;TLPreprocessor Got signal number: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">lights</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span>
        <span class="o">&lt;&lt;</span> <span class="s">&quot;, ts: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">timestamp</span><span class="p">);</span>
  <span class="c1">// 大部分情况下是没有信号灯的，此时我们默认选择焦距最大的相机，只是为了让红绿灯模块有输出</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lights</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No signals, select camera with max focal length: &quot;</span>
          <span class="o">&lt;&lt;</span> <span class="n">selected_camera_name_</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="c1">// ProjectLightsAndSelectCamera() 为具体投影选相机的方法</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ProjectLightsAndSelectCamera</span><span class="p">(</span><span class="n">pose</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span>
                                    <span class="o">&amp;</span><span class="p">(</span><span class="n">selected_camera_name_</span><span class="p">.</span><span class="n">second</span><span class="p">),</span> <span class="n">lights</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">AERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;project_lights_and_select_camera failed, ts: &quot;</span>
           <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">timestamp</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">TLPreprocessor</span><span class="o">::</span><span class="n">ProjectLightsAndSelectCamera</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">CarPose</span> <span class="o">&amp;</span><span class="n">pose</span><span class="p">,</span> <span class="k">const</span> <span class="n">TLPreprocessorOption</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">selected_camera_name</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">lights</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 两个数组，分别保存投影在/不在图像上的灯</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">light_ptrs</span> <span class="p">:</span> <span class="n">lights_on_image_array_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">light_ptrs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="o">&amp;</span><span class="nl">light_ptrs</span> <span class="p">:</span> <span class="n">lights_outside_image_array_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">light_ptrs</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="c1">// project light region on each camera&#39;s image plane</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">camera_names</span> <span class="o">=</span> <span class="n">projection_</span><span class="p">.</span><span class="n">getCameraNamesByDescendingFocalLen</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">cam_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cam_id</span> <span class="o">&lt;</span> <span class="n">num_cameras_</span><span class="p">;</span> <span class="o">++</span><span class="n">cam_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">camera_name</span> <span class="o">=</span> <span class="n">camera_names</span><span class="p">[</span><span class="n">cam_id</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ProjectLights</span><span class="p">(</span><span class="n">pose</span><span class="p">,</span> <span class="n">camera_name</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span>
                       <span class="o">&amp;</span><span class="p">(</span><span class="n">lights_on_image_array_</span><span class="p">[</span><span class="n">cam_id</span><span class="p">]),</span>
                       <span class="o">&amp;</span><span class="p">(</span><span class="n">lights_outside_image_array_</span><span class="p">[</span><span class="n">cam_id</span><span class="p">])))</span> <span class="p">{</span>
      <span class="n">AERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;select_camera_by_lights_projection project lights on &quot;</span>
             <span class="o">&lt;&lt;</span> <span class="n">camera_name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; image failed&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// ...</span>
  <span class="c1">// 根据投影结果选择相机</span>
  <span class="n">SelectCamera</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lights_on_image_array_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lights_outside_image_array_</span><span class="p">,</span> <span class="n">option</span><span class="p">,</span>
               <span class="n">selected_camera_name</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">TLPreprocessor</span><span class="o">::</span><span class="n">SelectCamera</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtrs</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">lights_on_image_array</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtrs</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">lights_outside_image_array</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">TLPreprocessorOption</span> <span class="o">&amp;</span><span class="n">option</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">*</span><span class="n">selected_camera_name</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// do not check boundary if this is min focal camera</span>
  <span class="k">auto</span> <span class="n">min_focal_len_working_camera</span> <span class="o">=</span> <span class="n">GetMinFocalLenWorkingCameraName</span><span class="p">();</span>
  <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;working camera with minimum focal length: &quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">min_focal_len_working_camera</span><span class="p">;</span>

  <span class="c1">// 按照焦距从大到小遍历相机，检查是否有灯的投影</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">camera_names</span> <span class="o">=</span> <span class="n">projection_</span><span class="p">.</span><span class="n">getCameraNamesByDescendingFocalLen</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">cam_id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">cam_id</span> <span class="o">&lt;</span> <span class="n">lights_on_image_array</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">cam_id</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">camera_name</span> <span class="o">=</span> <span class="n">camera_names</span><span class="p">[</span><span class="n">cam_id</span><span class="p">];</span>
    <span class="kt">bool</span> <span class="n">ok</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">camera_name</span> <span class="o">!=</span> <span class="n">min_focal_len_working_camera</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// 有灯无法投影到该相机上，跳过</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">lights_outside_image_array</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">cam_id</span><span class="p">).</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;light project out of image, &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot;camera_name: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">camera_name</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; lights_outside_image_array-&gt;at(cam_id).size(): &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">lights_outside_image_array</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">cam_id</span><span class="p">).</span><span class="n">size</span><span class="p">();</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// 投影边界检查</span>
      <span class="k">auto</span> <span class="n">lights</span> <span class="o">=</span> <span class="n">lights_on_image_array</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">cam_id</span><span class="p">);</span>
      <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="nl">light</span> <span class="p">:</span> <span class="n">lights</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// check boundary</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">OutOfValidRegion</span><span class="p">(</span><span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">projection_roi</span><span class="p">,</span>
                             <span class="n">projection_</span><span class="p">.</span><span class="n">getImageWidth</span><span class="p">(</span><span class="n">camera_name</span><span class="p">),</span>
                             <span class="n">projection_</span><span class="p">.</span><span class="n">getImageHeight</span><span class="p">(</span><span class="n">camera_name</span><span class="p">),</span>
                             <span class="n">option</span><span class="p">.</span><span class="n">image_borders_size</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">camera_name</span><span class="p">)))</span> <span class="p">{</span>
          <span class="n">ok</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
          <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;light project out of image region, &quot;</span>
                <span class="o">&lt;&lt;</span> <span class="s">&quot;camera_name: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">camera_name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; border_size: &quot;</span>
                <span class="o">&lt;&lt;</span> <span class="n">option</span><span class="p">.</span><span class="n">image_borders_size</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">camera_name</span><span class="p">);</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// do not checkout the boundary if this is min focal camera</span>
      <span class="n">ok</span> <span class="o">=</span> <span class="p">(</span><span class="n">lights_on_image_array</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">cam_id</span><span class="p">).</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ok</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">*</span><span class="n">selected_camera_name</span> <span class="o">=</span> <span class="n">camera_name</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p><code>multi_camera_projection.cc</code> ：</p>
<div class="hlcode"><pre><span></span><span class="kt">bool</span> <span class="n">MultiCamerasProjection</span><span class="o">::</span><span class="n">BoundaryBasedProject</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">base</span><span class="o">::</span><span class="n">BrownCameraDistortionModelPtr</span> <span class="n">camera_model</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Eigen</span><span class="o">::</span><span class="n">Matrix4d</span><span class="o">&amp;</span> <span class="n">c2w_pose</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">PointXYZID</span><span class="o">&gt;&amp;</span> <span class="n">points</span><span class="p">,</span>
    <span class="n">base</span><span class="o">::</span><span class="n">TrafficLight</span><span class="o">*</span> <span class="n">light</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">camera_model</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">camera_model</span><span class="o">-&gt;</span><span class="n">get_width</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">height</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">camera_model</span><span class="o">-&gt;</span><span class="n">get_height</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">bound_size</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">points</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bound size &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">bound_size</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">bound_size</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AERROR</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;invalid bound_size&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Eigen</span><span class="o">::</span><span class="n">Vector2i</span><span class="o">&gt;</span> <span class="n">pts2d</span><span class="p">(</span><span class="n">bound_size</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">c2w_pose_inverse</span> <span class="o">=</span> <span class="n">c2w_pose</span><span class="p">.</span><span class="n">inverse</span><span class="p">();</span>

  <span class="c1">// 将 HDMap 中的 signal 的 boundary points 投影到图像上</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">bound_size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">pt3d_world</span> <span class="o">=</span> <span class="n">points</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector3d</span> <span class="n">pt3d_cam</span> <span class="o">=</span>
        <span class="p">(</span><span class="n">c2w_pose_inverse</span> <span class="o">*</span>
         <span class="n">Eigen</span><span class="o">::</span><span class="n">Vector4d</span><span class="p">(</span><span class="n">pt3d_world</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">pt3d_world</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">pt3d_world</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
            <span class="p">.</span><span class="n">head</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">islessequal</span><span class="p">(</span><span class="n">pt3d_cam</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">AWARN</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;light bound point behind the car: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">pt3d_cam</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">pts2d</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">camera_model</span><span class="o">-&gt;</span><span class="n">Project</span><span class="p">(</span><span class="n">pt3d_cam</span><span class="p">.</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">()).</span><span class="n">cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// 取投影点的 bounding box</span>
  <span class="kt">int</span> <span class="n">min_x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">max_x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">min_y</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">max_y</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">min</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">pt</span> <span class="p">:</span> <span class="n">pts2d</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">min_x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">min_x</span><span class="p">);</span>
    <span class="n">max_x</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">max_x</span><span class="p">);</span>
    <span class="n">min_y</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">min_y</span><span class="p">);</span>
    <span class="n">max_y</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">pt</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">max_y</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">base</span><span class="o">::</span><span class="n">BBox2DI</span> <span class="n">roi</span><span class="p">(</span><span class="n">min_x</span><span class="p">,</span> <span class="n">min_y</span><span class="p">,</span> <span class="n">max_x</span><span class="p">,</span> <span class="n">max_y</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutOfValidRegion</span><span class="p">(</span><span class="n">roi</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">||</span> <span class="n">roi</span><span class="p">.</span><span class="n">Area</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AWARN</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Projection get ROI outside the image. &quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">projection_roi</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">RectI</span><span class="p">(</span><span class="n">roi</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3 id="22-detectordetection">2.2 detector/detection</h3>
<p>检测，根据灯的投影在 Crop ROI 中给出红绿灯 2D 框</p>
<p><img alt="" src="/wiki/attach/images/baidu_apollo_trafficlights_codes_reading/tl_detect.png" /></p>
<div class="hlcode"><pre><span></span><span class="n">detection</span><span class="o">/</span>
  <span class="err">├──</span> <span class="n">detection</span><span class="p">.</span><span class="n">proto</span>    <span class="o">#</span> <span class="err">配置定义</span>
  <span class="err">├──</span> <span class="n">detection</span><span class="p">.</span><span class="n">cc</span>
  <span class="err">├──</span> <span class="n">detection</span><span class="p">.</span><span class="n">h</span>        <span class="o">#</span> <span class="n">TrafficLightDetection</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="err">├──</span> <span class="n">cropbox</span><span class="p">.</span><span class="n">cc</span>
  <span class="err">├──</span> <span class="n">cropbox</span><span class="p">.</span><span class="n">h</span>          <span class="o">#</span> <span class="err">用于根据红绿灯投影框获取</span> <span class="n">Crop</span> <span class="n">ROI</span>
  <span class="err">├──</span> <span class="k">select</span><span class="p">.</span><span class="n">cc</span>
  <span class="err">└──</span> <span class="k">select</span><span class="p">.</span><span class="n">h</span>           <span class="o">#</span> <span class="err">候选检测框与红绿灯投影框匹配</span>
</pre></div>


<p><code>detection.cc</code> 主要函数介绍:</p>
<div class="hlcode"><pre><span></span><span class="kt">bool</span> <span class="n">TrafficLightDetection</span><span class="o">::</span><span class="n">Detect</span><span class="p">(</span><span class="k">const</span> <span class="n">TrafficLightDetectorOptions</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">,</span>
                                   <span class="n">CameraFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">data_provider</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">data_provider</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">input_blob</span> <span class="o">=</span> <span class="n">rt_net_</span><span class="o">-&gt;</span><span class="n">get_blob</span><span class="p">(</span><span class="n">net_inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="c1">// ...</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">lights_ref</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">traffic_lights</span><span class="p">;</span>

  <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;detection input &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">lights_ref</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; lights&quot;</span><span class="p">;</span>
  <span class="c1">// detected_bboxes_ 是模型给出的所有候选检测框</span>
  <span class="n">detected_bboxes_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="c1">// selected_bboxes_ 是匹配后的检测框</span>
  <span class="n">selected_bboxes_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>

  <span class="c1">// ...</span>
  <span class="c1">// 检测模型 inference</span>
  <span class="n">Inference</span><span class="p">(</span><span class="o">&amp;</span><span class="n">lights_ref</span><span class="p">,</span> <span class="n">data_provider</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">detected_bboxes_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">base</span><span class="o">::</span><span class="n">RectI</span> <span class="o">&amp;</span><span class="n">region</span> <span class="o">=</span> <span class="n">detected_bboxes_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">detection_roi</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">score</span> <span class="o">=</span> <span class="n">detected_bboxes_</span><span class="p">[</span><span class="n">j</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">detect_score</span><span class="p">;</span>
    <span class="n">lights_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">debug_roi</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">region</span><span class="p">);</span>
    <span class="n">lights_ref</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">debug_roi_detect_scores</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">score</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// 匹配，为每个投影框选择一个检测框</span>
  <span class="n">select_</span><span class="p">.</span><span class="n">SelectTrafficLights</span><span class="p">(</span><span class="n">detected_bboxes_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lights_ref</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">TrafficLightDetection</span><span class="o">::</span><span class="n">Inference</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">lights</span><span class="p">,</span> <span class="n">DataProvider</span> <span class="o">*</span><span class="n">data_provider</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
  <span class="n">crop_box_list_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>        <span class="c1">// 保存 Crop ROI</span>
  <span class="n">resize_scale_list_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>    <span class="c1">// 保存 2D 检测框缩放比例</span>
  <span class="kt">int</span> <span class="n">img_width</span> <span class="o">=</span> <span class="n">data_provider</span><span class="o">-&gt;</span><span class="n">src_width</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">img_height</span> <span class="o">=</span> <span class="n">data_provider</span><span class="o">-&gt;</span><span class="n">src_height</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">resize_index</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">batch_num</span> <span class="o">=</span> <span class="n">lights</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>
  <span class="k">auto</span> <span class="n">input_img_blob</span> <span class="o">=</span> <span class="n">rt_net_</span><span class="o">-&gt;</span><span class="n">get_blob</span><span class="p">(</span><span class="n">net_inputs_</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
  <span class="k">auto</span> <span class="n">input_param</span> <span class="o">=</span> <span class="n">rt_net_</span><span class="o">-&gt;</span><span class="n">get_blob</span><span class="p">(</span><span class="n">net_inputs_</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>

  <span class="c1">// 每个 Crop ROI 都 resize 到 [min_crop_size x min_crop_size] 再进行检测</span>
  <span class="n">input_img_blob</span><span class="o">-&gt;</span><span class="n">Reshape</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">batch_num</span><span class="p">),</span>
                          <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">detection_param_</span><span class="p">.</span><span class="n">min_crop_size</span><span class="p">()),</span>
                          <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">detection_param_</span><span class="p">.</span><span class="n">min_crop_size</span><span class="p">()),</span>
                          <span class="mi">3</span><span class="p">);</span>
  <span class="n">param_blob_</span><span class="o">-&gt;</span><span class="n">Reshape</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">batch_num</span><span class="p">),</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="kt">float</span> <span class="o">*</span><span class="n">param_data</span> <span class="o">=</span> <span class="n">param_blob_</span><span class="o">-&gt;</span><span class="n">mutable_cpu_data</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">batch_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">param_blob_length_</span><span class="p">;</span>
    <span class="n">param_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">detection_param_</span><span class="p">.</span><span class="n">min_crop_size</span><span class="p">());</span>
    <span class="n">param_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">detection_param_</span><span class="p">.</span><span class="n">min_crop_size</span><span class="p">());</span>
    <span class="n">param_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">param_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">param_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">param_data</span><span class="p">[</span><span class="n">offset</span> <span class="o">+</span> <span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">batch_num</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span> <span class="n">light</span> <span class="o">=</span> <span class="n">lights</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">base</span><span class="o">::</span><span class="n">RectI</span> <span class="n">cbox</span><span class="p">;</span>
    <span class="c1">// 计算 Crop ROI</span>
    <span class="n">crop_</span><span class="o">-&gt;</span><span class="n">getCropBox</span><span class="p">(</span><span class="n">img_width</span><span class="p">,</span> <span class="n">img_height</span><span class="p">,</span> <span class="n">light</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">cbox</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OutOfValidRegion</span><span class="p">(</span><span class="n">cbox</span><span class="p">,</span> <span class="n">img_width</span><span class="p">,</span> <span class="n">img_height</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">cbox</span><span class="p">.</span><span class="n">Area</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">crop_box_list_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">cbox</span><span class="p">);</span>
      <span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">debug_roi</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cbox</span><span class="p">;</span>
      <span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">crop_roi</span> <span class="o">=</span> <span class="n">cbox</span><span class="p">;</span>

      <span class="n">data_provider_image_option_</span><span class="p">.</span><span class="n">do_crop</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">data_provider_image_option_</span><span class="p">.</span><span class="n">crop_roi</span> <span class="o">=</span> <span class="n">cbox</span><span class="p">;</span>
      <span class="n">data_provider_image_option_</span><span class="p">.</span><span class="n">target_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">Color</span><span class="o">::</span><span class="n">BGR</span><span class="p">;</span>
      <span class="n">data_provider</span><span class="o">-&gt;</span><span class="n">GetImage</span><span class="p">(</span><span class="n">data_provider_image_option_</span><span class="p">,</span> <span class="n">image_</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>

      <span class="c1">// 保存缩放比例，用于还原原图像中的检测框</span>
      <span class="kt">float</span> <span class="n">resize_scale</span> <span class="o">=</span>
          <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">detection_param_</span><span class="p">.</span><span class="n">min_crop_size</span><span class="p">())</span> <span class="o">/</span>
          <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">cbox</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">cbox</span><span class="p">.</span><span class="n">height</span><span class="p">));</span>
      <span class="n">resize_scale_list_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">resize_scale</span><span class="p">);</span>

      <span class="c1">// 将所有 Crop ROI 都 resize 到相同大小</span>
      <span class="n">inference</span><span class="o">::</span><span class="n">ResizeGPU</span><span class="p">(</span><span class="o">*</span><span class="n">image_</span><span class="p">,</span> <span class="n">input_img_blob</span><span class="p">,</span> <span class="n">img_width</span><span class="p">,</span> <span class="n">resize_index</span><span class="p">,</span>
                           <span class="n">mean_</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mean_</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mean_</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">true</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">);</span>
      <span class="n">resize_index</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// Inference</span>
  <span class="n">cudaDeviceSynchronize</span><span class="p">();</span>
  <span class="n">rt_net_</span><span class="o">-&gt;</span><span class="n">Infer</span><span class="p">();</span>
  <span class="n">cudaDeviceSynchronize</span><span class="p">();</span>

  <span class="c1">// 还原原图像中的检测框</span>
  <span class="n">SelectOutputBoxes</span><span class="p">(</span><span class="n">crop_box_list_</span><span class="p">,</span> <span class="n">resize_scale_list_</span><span class="p">,</span> <span class="n">resize_scale_list_</span><span class="p">,</span>
                    <span class="o">&amp;</span><span class="n">detected_bboxes_</span><span class="p">);</span>

  <span class="c1">// NMS，消除有重叠区域的 Crop ROIs 中重复的检测框</span>
  <span class="n">ApplyNMS</span><span class="p">(</span><span class="o">&amp;</span><span class="n">detected_bboxes_</span><span class="p">);</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><code>cropbox.cc</code> :</p>
<div class="hlcode"><pre><span></span><span class="kt">void</span> <span class="n">CropBox</span><span class="o">::</span><span class="n">Init</span><span class="p">(</span><span class="kt">float</span> <span class="n">crop_scale</span><span class="p">,</span> <span class="kt">int</span> <span class="n">min_crop_size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">crop_scale_</span> <span class="o">=</span> <span class="n">crop_scale</span><span class="p">;</span>          <span class="c1">// 缩放倍数</span>
  <span class="n">min_crop_size_</span> <span class="o">=</span> <span class="n">min_crop_size</span><span class="p">;</span>    <span class="c1">// 最小 crop size</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">CropBox</span><span class="o">::</span><span class="n">getCropBox</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span> <span class="o">&amp;</span><span class="n">light</span><span class="p">,</span>
                         <span class="n">base</span><span class="o">::</span><span class="n">RectI</span> <span class="o">*</span><span class="n">crop_box</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">rows</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">cols</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutOfValidRegion</span><span class="p">(</span><span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">projection_roi</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">projection_roi</span><span class="p">.</span><span class="n">Area</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">crop_box</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">crop_box</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">crop_box</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">crop_box</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">int</span> <span class="n">xl</span> <span class="o">=</span> <span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">projection_roi</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">yt</span> <span class="o">=</span> <span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">projection_roi</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">xr</span> <span class="o">=</span> <span class="n">xl</span> <span class="o">+</span> <span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">projection_roi</span><span class="p">.</span><span class="n">width</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">yb</span> <span class="o">=</span> <span class="n">yt</span> <span class="o">+</span> <span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">projection_roi</span><span class="p">.</span><span class="n">height</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>

  <span class="c1">// 取 projection roi 的长边，乘以 crop_scale 作为 Crop ROI 的边长</span>
  <span class="kt">int</span> <span class="n">center_x</span> <span class="o">=</span> <span class="p">(</span><span class="n">xr</span> <span class="o">+</span> <span class="n">xl</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">center_y</span> <span class="o">=</span> <span class="p">(</span><span class="n">yb</span> <span class="o">+</span> <span class="n">yt</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">resize</span> <span class="o">=</span>
      <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">crop_scale_</span> <span class="o">*</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span>
                                         <span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">projection_roi</span><span class="p">.</span><span class="n">width</span><span class="p">,</span>
                                         <span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">projection_roi</span><span class="p">.</span><span class="n">height</span><span class="p">)));</span>
  <span class="c1">// 限制 Crop ROI 最小边长</span>
  <span class="n">resize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">resize</span><span class="p">,</span> <span class="n">min_crop_size_</span><span class="p">);</span>
  <span class="n">resize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">resize</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
  <span class="n">resize</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">resize</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>

  <span class="c1">// 计算新的 left top 和 right bottom 点</span>
  <span class="n">xl</span> <span class="o">=</span> <span class="n">center_x</span> <span class="o">-</span> <span class="n">resize</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">xl</span> <span class="o">=</span> <span class="p">(</span><span class="n">xl</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">xl</span><span class="p">;</span>
  <span class="n">yt</span> <span class="o">=</span> <span class="n">center_y</span> <span class="o">-</span> <span class="n">resize</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">yt</span> <span class="o">=</span> <span class="p">(</span><span class="n">yt</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="n">yt</span><span class="p">;</span>
  <span class="n">xr</span> <span class="o">=</span> <span class="n">xl</span> <span class="o">+</span> <span class="n">resize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">yb</span> <span class="o">=</span> <span class="n">yt</span> <span class="o">+</span> <span class="n">resize</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">xr</span> <span class="o">&gt;=</span> <span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">xl</span> <span class="o">-=</span> <span class="n">xr</span> <span class="o">-</span> <span class="n">cols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">xr</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">yb</span> <span class="o">&gt;=</span> <span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">yt</span> <span class="o">-=</span> <span class="n">yb</span> <span class="o">-</span> <span class="n">rows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">yb</span> <span class="o">=</span> <span class="n">rows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">crop_box</span><span class="o">-&gt;</span><span class="n">x</span> <span class="o">=</span> <span class="n">xl</span><span class="p">;</span>
  <span class="n">crop_box</span><span class="o">-&gt;</span><span class="n">y</span> <span class="o">=</span> <span class="n">yt</span><span class="p">;</span>
  <span class="n">crop_box</span><span class="o">-&gt;</span><span class="n">width</span> <span class="o">=</span> <span class="n">xr</span> <span class="o">-</span> <span class="n">xl</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">crop_box</span><span class="o">-&gt;</span><span class="n">height</span> <span class="o">=</span> <span class="n">yb</span> <span class="o">-</span> <span class="n">yt</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<p><code>select.cc</code> :</p>
<div class="hlcode"><pre><span></span><span class="kt">void</span> <span class="n">Select</span><span class="o">::</span><span class="n">SelectTrafficLights</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">refined_bboxes</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">hdmap_bboxes</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// 将投影框和候选检测框进行匈牙利匹配</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="p">,</span> <span class="kt">size_t</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">assignments</span><span class="p">;</span>
  <span class="n">munkres_</span><span class="p">.</span><span class="n">costs</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">Resize</span><span class="p">(</span><span class="n">hdmap_bboxes</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">(),</span> <span class="n">refined_bboxes</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">row</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">row</span> <span class="o">&lt;</span> <span class="n">hdmap_bboxes</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">row</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">center_hd</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">hdmap_bboxes</span><span class="p">)[</span><span class="n">row</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">detection_roi</span><span class="p">.</span><span class="n">Center</span><span class="p">();</span>
    <span class="c1">// 地图灯的投影在图像外，对应 score 置 0</span>
    <span class="k">if</span> <span class="p">((</span><span class="o">*</span><span class="n">hdmap_bboxes</span><span class="p">)[</span><span class="n">row</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">outside_image</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;projection_roi outside image, set score to 0.&quot;</span><span class="p">;</span>
      <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">refined_bboxes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">col</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">(</span><span class="o">*</span><span class="n">munkres_</span><span class="p">.</span><span class="n">costs</span><span class="p">())(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// 计算 score 矩阵</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">col</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">col</span> <span class="o">&lt;</span> <span class="n">refined_bboxes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">col</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">float</span> <span class="n">gaussian_score</span> <span class="o">=</span> <span class="mf">100.0f</span><span class="p">;</span>
      <span class="k">auto</span> <span class="n">center_refine</span> <span class="o">=</span> <span class="n">refined_bboxes</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">detection_roi</span><span class="p">.</span><span class="n">Center</span><span class="p">();</span>
      <span class="c1">// use gaussian score as metrics of distance and width</span>
      <span class="kt">double</span> <span class="n">distance_score</span> <span class="o">=</span> <span class="n">Calc2dGaussianScore</span><span class="p">(</span>
          <span class="n">center_hd</span><span class="p">,</span> <span class="n">center_refine</span><span class="p">,</span> <span class="n">gaussian_score</span><span class="p">,</span> <span class="n">gaussian_score</span><span class="p">);</span>

      <span class="kt">double</span> <span class="n">max_score</span> <span class="o">=</span> <span class="mf">0.9</span><span class="p">;</span>
      <span class="k">auto</span> <span class="n">detect_score</span> <span class="o">=</span> <span class="n">refined_bboxes</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">detect_score</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">detection_score</span> <span class="o">=</span>
          <span class="n">detect_score</span> <span class="o">&gt;</span> <span class="n">max_score</span> <span class="o">?</span> <span class="nl">max_score</span> <span class="p">:</span> <span class="n">detect_score</span><span class="p">;</span>

      <span class="kt">double</span> <span class="n">distance_weight</span> <span class="o">=</span> <span class="mf">0.7</span><span class="p">;</span>
      <span class="kt">double</span> <span class="n">detection_weight</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">distance_weight</span><span class="p">;</span>
      <span class="c1">// 图像上 2D 距离分数和检测模型 confidence 的加权平均</span>
      <span class="c1">// 分数越大表示匹配程度越高</span>
      <span class="p">(</span><span class="o">*</span><span class="n">munkres_</span><span class="p">.</span><span class="n">costs</span><span class="p">())(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span>
          <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">float</span><span class="o">&gt;</span><span class="p">(</span><span class="n">detection_weight</span> <span class="o">*</span> <span class="n">detection_score</span> <span class="o">+</span>
                             <span class="n">distance_weight</span> <span class="o">*</span> <span class="n">distance_score</span><span class="p">);</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">crop_roi</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">hdmap_bboxes</span><span class="p">)[</span><span class="n">row</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">crop_roi</span><span class="p">;</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">detection_roi</span> <span class="o">=</span> <span class="n">refined_bboxes</span><span class="p">[</span><span class="n">col</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">detection_roi</span><span class="p">;</span>
      <span class="c1">// 如果候选检测框不是完全在当前 Crop ROI 之内， score 置 0</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">detection_roi</span> <span class="o">&amp;</span> <span class="n">crop_roi</span><span class="p">)</span> <span class="o">!=</span> <span class="n">detection_roi</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;detection_roi outside crop_roi, set score to 0.&quot;</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; detection_roi: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">detection_roi</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">detection_roi</span><span class="p">.</span><span class="n">y</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">detection_roi</span><span class="p">.</span><span class="n">width</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">detection_roi</span><span class="p">.</span><span class="n">height</span>
              <span class="o">&lt;&lt;</span> <span class="s">&quot; crop_roi: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">crop_roi</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">crop_roi</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span>
              <span class="o">&lt;&lt;</span> <span class="n">crop_roi</span><span class="p">.</span><span class="n">width</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">crop_roi</span><span class="p">.</span><span class="n">height</span><span class="p">;</span>
        <span class="p">(</span><span class="o">*</span><span class="n">munkres_</span><span class="p">.</span><span class="n">costs</span><span class="p">())(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">)</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;score &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">munkres_</span><span class="p">.</span><span class="n">costs</span><span class="p">())(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="c1">// 求解匹配</span>
  <span class="n">munkres_</span><span class="p">.</span><span class="n">Maximize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">assignments</span><span class="p">);</span>

  <span class="c1">// 为每个灯分配检测框</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">hdmap_bboxes</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">(</span><span class="o">*</span><span class="n">hdmap_bboxes</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">is_selected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">(</span><span class="o">*</span><span class="n">hdmap_bboxes</span><span class="p">)[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">is_detected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">assignments</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="n">hdmap_bboxes</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span>
        <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span>
            <span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span> <span class="o">&gt;=</span> <span class="n">refined_bboxes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">||</span>
            <span class="p">(</span><span class="o">*</span><span class="n">hdmap_bboxes</span><span class="p">)[</span><span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">is_selected</span> <span class="o">||</span>
            <span class="n">refined_bboxes</span><span class="p">[</span><span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">is_selected</span><span class="p">))</span> <span class="p">{</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">auto</span> <span class="o">&amp;</span><span class="n">refined_bbox_region</span> <span class="o">=</span> <span class="n">refined_bboxes</span><span class="p">[</span><span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">;</span>
      <span class="k">auto</span> <span class="o">&amp;</span><span class="n">hdmap_bbox_region</span> <span class="o">=</span> <span class="p">(</span><span class="o">*</span><span class="n">hdmap_bboxes</span><span class="p">)[</span><span class="n">assignments</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">;</span>
      <span class="n">refined_bbox_region</span><span class="p">.</span><span class="n">is_selected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">hdmap_bbox_region</span><span class="p">.</span><span class="n">is_selected</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

      <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">crop_roi</span> <span class="o">=</span> <span class="n">hdmap_bbox_region</span><span class="p">.</span><span class="n">crop_roi</span><span class="p">;</span>
      <span class="k">const</span> <span class="k">auto</span> <span class="o">&amp;</span><span class="n">detection_roi</span> <span class="o">=</span> <span class="n">refined_bbox_region</span><span class="p">.</span><span class="n">detection_roi</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">outside_crop_roi</span> <span class="o">=</span> <span class="p">((</span><span class="n">crop_roi</span> <span class="o">&amp;</span> <span class="n">detection_roi</span><span class="p">)</span> <span class="o">!=</span> <span class="n">detection_roi</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">hdmap_bbox_region</span><span class="p">.</span><span class="n">outside_image</span> <span class="o">||</span> <span class="n">outside_crop_roi</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">hdmap_bbox_region</span><span class="p">.</span><span class="n">is_detected</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">hdmap_bbox_region</span><span class="p">.</span><span class="n">detection_roi</span> <span class="o">=</span> <span class="n">refined_bbox_region</span><span class="p">.</span><span class="n">detection_roi</span><span class="p">;</span>
        <span class="n">hdmap_bbox_region</span><span class="p">.</span><span class="n">detect_class_id</span> <span class="o">=</span> <span class="n">refined_bbox_region</span><span class="p">.</span><span class="n">detect_class_id</span><span class="p">;</span>
        <span class="n">hdmap_bbox_region</span><span class="p">.</span><span class="n">detect_score</span> <span class="o">=</span> <span class="n">refined_bbox_region</span><span class="p">.</span><span class="n">detect_score</span><span class="p">;</span>
        <span class="n">hdmap_bbox_region</span><span class="p">.</span><span class="n">is_detected</span> <span class="o">=</span> <span class="n">refined_bbox_region</span><span class="p">.</span><span class="n">is_detected</span><span class="p">;</span>
        <span class="n">hdmap_bbox_region</span><span class="p">.</span><span class="n">is_selected</span> <span class="o">=</span> <span class="n">refined_bbox_region</span><span class="p">.</span><span class="n">is_selected</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h3 id="23-detectorrecognition">2.3 detector/recognition</h3>
<p>识别，对检测结果进行分类，给出颜色识别结果</p>
<div class="hlcode"><pre><span></span><span class="n">recognition</span><span class="o">/</span>
  <span class="err">├──</span> <span class="n">recognition</span><span class="p">.</span><span class="n">proto</span>  <span class="o">#</span> <span class="err">配置定义</span>
  <span class="err">├──</span> <span class="n">recognition</span><span class="p">.</span><span class="n">cc</span>
  <span class="err">├──</span> <span class="n">recognition</span><span class="p">.</span><span class="n">h</span>      <span class="o">#</span> <span class="n">TrafficLightRecognition</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
  <span class="err">├──</span> <span class="n">classify</span><span class="p">.</span><span class="n">cc</span>
  <span class="err">└──</span> <span class="n">classify</span><span class="p">.</span><span class="n">h</span>         <span class="o">#</span> <span class="n">classification</span> <span class="n">inference</span>
</pre></div>


<p>主要函数：</p>
<div class="hlcode"><pre><span></span><span class="kt">bool</span> <span class="n">TrafficLightRecognition</span><span class="o">::</span><span class="n">Detect</span><span class="p">(</span><span class="k">const</span> <span class="n">TrafficLightDetectorOptions</span><span class="o">&amp;</span> <span class="n">options</span><span class="p">,</span>
                                     <span class="n">CameraFrame</span><span class="o">*</span> <span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="n">candidate</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span> <span class="nl">light</span> <span class="p">:</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">traffic_lights</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">is_detected</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">candidate</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">light</span><span class="p">;</span>
      <span class="c1">// 检测模型输出的检测框有三个类别，分别对应方形、竖直和水平形状</span>
      <span class="c1">// 每种形状都有一个识别模型</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">detect_class_id</span> <span class="o">==</span>
          <span class="n">base</span><span class="o">::</span><span class="n">TLDetectionClass</span><span class="o">::</span><span class="n">TL_QUADRATE_CLASS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Recognize Use Quadrate Model!&quot;</span><span class="p">;</span>
        <span class="n">classify_quadrate_</span><span class="o">-&gt;</span><span class="n">Perform</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">candidate</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">detect_class_id</span> <span class="o">==</span>
                 <span class="n">base</span><span class="o">::</span><span class="n">TLDetectionClass</span><span class="o">::</span><span class="n">TL_VERTICAL_CLASS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Recognize Use Vertical Model!&quot;</span><span class="p">;</span>
        <span class="n">classify_vertical_</span><span class="o">-&gt;</span><span class="n">Perform</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">candidate</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">light</span><span class="o">-&gt;</span><span class="n">region</span><span class="p">.</span><span class="n">detect_class_id</span> <span class="o">==</span>
                 <span class="n">base</span><span class="o">::</span><span class="n">TLDetectionClass</span><span class="o">::</span><span class="n">TL_HORIZONTAL_CLASS</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">AINFO</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Recognize Use Horizonal Model!&quot;</span><span class="p">;</span>
        <span class="n">classify_horizontal_</span><span class="o">-&gt;</span><span class="n">Perform</span><span class="p">(</span><span class="n">frame</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">candidate</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="c1">// 未检测到，输出 Unknown color</span>
      <span class="n">light</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_UNKNOWN_COLOR</span><span class="p">;</span>
      <span class="n">light</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">confidence</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<h3 id="24-tracker">2.4 tracker</h3>
<p>修正，红绿灯语义、时序校正</p>
<div class="hlcode"><pre><span></span><span class="n">tracker</span><span class="o">/</span>
  <span class="err">├──</span> <span class="n">semantic</span><span class="p">.</span><span class="n">proto</span>         <span class="o">#</span> <span class="err">配置定义</span>
  <span class="err">├──</span> <span class="n">semantic_decision</span><span class="p">.</span><span class="n">cc</span>
  <span class="err">└──</span> <span class="n">semantic_decision</span><span class="p">.</span><span class="n">h</span>    <span class="o">#</span> <span class="n">SemanticReviser</span> <span class="p">(</span><span class="o">*</span><span class="p">)</span>
</pre></div>


<p>语义校正：</p>
<p>当前时刻，同一语义的红绿灯中，输出置信度最高的颜色。如果置信度最高的颜色有多种，输出数量最多的。如果数量相同，输出unknown（比如一红一绿）。</p>
<p>时序校正：</p>
<p>基于一些规则对模型结果进行后处理。例如，某帧漏检出现 unknown color，根据前 1.5 秒内有颜色的输出将当前帧结果修正为该颜色，保证输出结果稳定；黄灯误识别为红灯，将之后的颜色均校正为红色(硬策略，避免黄灯出现在红灯之后给 PnC 造成困扰)。</p>
<p>主要函数：</p>
<div class="hlcode"><pre><span></span><span class="kt">bool</span> <span class="n">SemanticReviser</span><span class="o">::</span><span class="n">Track</span><span class="p">(</span><span class="k">const</span> <span class="n">TrafficLightTrackerOptions</span> <span class="o">&amp;</span><span class="n">options</span><span class="p">,</span>
                            <span class="n">CameraFrame</span> <span class="o">*</span><span class="n">frame</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">time_stamp</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">timestamp</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">lights_ref</span> <span class="o">=</span> <span class="n">frame</span><span class="o">-&gt;</span><span class="n">traffic_lights</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SemanticTable</span><span class="o">&gt;</span> <span class="n">semantic_table</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">lights_ref</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">history_semantic_</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;no lights to revise, return&quot;</span><span class="p">;</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 根据信号灯语义进行分组</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">lights_ref</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span> <span class="n">light</span> <span class="o">=</span> <span class="n">lights_ref</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">cur_semantic</span> <span class="o">=</span> <span class="n">light</span><span class="o">-&gt;</span><span class="n">semantic</span><span class="p">;</span>
    <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;light &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">light</span><span class="o">-&gt;</span><span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; semantic &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cur_semantic</span><span class="p">;</span>

    <span class="n">SemanticTable</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">stringstream</span> <span class="n">ss</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">cur_semantic</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Semantic_&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">cur_semantic</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">ss</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;No_semantic_light_&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">light</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">tmp</span><span class="p">.</span><span class="n">semantic</span> <span class="o">=</span> <span class="n">ss</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="n">tmp</span><span class="p">.</span><span class="n">light_ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="n">tmp</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">light</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
    <span class="n">tmp</span><span class="p">.</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">time_stamp</span><span class="p">;</span>
    <span class="n">tmp</span><span class="p">.</span><span class="n">blink</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">iter</span> <span class="o">=</span>
        <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">semantic_table</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">semantic_table</span><span class="p">),</span>
                     <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">compare</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">tmp</span><span class="p">));</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">iter</span><span class="o">-&gt;</span><span class="n">light_ids</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">semantic_table</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// 时序校正</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SemanticTable</span> <span class="n">cur_semantic_table</span> <span class="o">=</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">ReviseByTimeSeries</span><span class="p">(</span><span class="n">time_stamp</span><span class="p">,</span> <span class="n">cur_semantic_table</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">lights_ref</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>


<div class="hlcode"><pre><span></span><span class="c1">// 保存同语义红绿灯信息的数据结构</span>
<span class="c1">// 假设同语义的红绿灯状态是一致的</span>
<span class="k">struct</span> <span class="n">SemanticTable</span> <span class="p">{</span>
  <span class="kt">double</span> <span class="n">time_stamp</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">last_bright_time_stamp</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kt">double</span> <span class="n">last_dark_time_stamp</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">blink</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// 是否闪烁</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">semantic</span><span class="p">;</span>  <span class="c1">// 语义</span>
  <span class="c1">// semantic 是一个 4 位的 01 字符串，每一位分别标识 NO_TURN、U_TURN、LEFT_TURN、RIGHT_TURN</span>
  <span class="c1">// 如 `0010` 表示左转灯，`1010` 表示既控制左转也控制直行</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">light_ids</span><span class="p">;</span>  <span class="c1">// 红绿灯 ID</span>
  <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span> <span class="n">color</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>


<p>同语义灯校正：</p>
<div class="hlcode"><pre><span></span><span class="n">base</span><span class="o">::</span><span class="n">TLColor</span> <span class="n">SemanticReviser</span><span class="o">::</span><span class="n">ReviseBySemantic</span><span class="p">(</span>
    <span class="n">SemanticTable</span> <span class="n">semantic_table</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">lights</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vote</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_TOTAL_COLOR_NUM</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">lights_ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">lights</span><span class="p">;</span>
  <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span> <span class="n">max_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_UNKNOWN_COLOR</span><span class="p">;</span>

  <span class="c1">// 相同语义的灯，记录每种颜色出现的次数</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">light_ids</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">light_ids</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span> <span class="n">light</span> <span class="o">=</span> <span class="n">lights_ref</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
    <span class="k">auto</span> <span class="n">color</span> <span class="o">=</span> <span class="n">light</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">color</span><span class="p">;</span>
    <span class="n">vote</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">color</span><span class="p">))</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// 只有黑色或者 unknown 的情况</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">vote</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_RED</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
      <span class="p">(</span><span class="n">vote</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_GREEN</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
      <span class="p">(</span><span class="n">vote</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_YELLOW</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">vote</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_BLACK</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_BLACK</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_UNKNOWN_COLOR</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">vote</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_BLACK</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">vote</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_UNKNOWN_COLOR</span><span class="p">))</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// 出现数量最多的颜色</span>
  <span class="k">auto</span> <span class="n">biggest</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max_element</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">vote</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">vote</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">max_color_num</span> <span class="o">=</span> <span class="o">*</span><span class="n">biggest</span><span class="p">;</span>
  <span class="n">max_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">distance</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">vote</span><span class="p">),</span> <span class="n">biggest</span><span class="p">));</span>
  <span class="n">vote</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">biggest</span><span class="p">);</span>
  <span class="k">auto</span> <span class="n">second_biggest</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">max_element</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">vote</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">vote</span><span class="p">));</span>

  <span class="c1">// 如果数量最多的前两种颜色数量相同，返回 unknown</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">max_color_num</span> <span class="o">==</span> <span class="o">*</span><span class="n">second_biggest</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_UNKNOWN_COLOR</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">max_color</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<p>时序校正：</p>
<div class="hlcode"><pre><span></span><span class="kt">void</span> <span class="n">SemanticReviser</span><span class="o">::</span><span class="n">ReviseByTimeSeries</span><span class="p">(</span>
    <span class="kt">double</span> <span class="n">time_stamp</span><span class="p">,</span> <span class="n">SemanticTable</span> <span class="n">semantic_table</span><span class="p">,</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">*</span><span class="n">lights</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;revise &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">semantic</span>
         <span class="o">&lt;&lt;</span> <span class="s">&quot;, lights number:&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">light_ids</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">base</span><span class="o">::</span><span class="n">TrafficLightPtr</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">lights_ref</span> <span class="o">=</span> <span class="o">*</span><span class="n">lights</span><span class="p">;</span>
  <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span> <span class="n">cur_color</span> <span class="o">=</span> <span class="n">ReviseBySemantic</span><span class="p">(</span><span class="n">semantic_table</span><span class="p">,</span> <span class="n">lights</span><span class="p">);</span>
  <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span> <span class="n">pre_color</span> <span class="o">=</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_UNKNOWN_COLOR</span><span class="p">;</span>
  <span class="n">semantic_table</span><span class="p">.</span><span class="n">color</span> <span class="o">=</span> <span class="n">cur_color</span><span class="p">;</span>
  <span class="n">semantic_table</span><span class="p">.</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">time_stamp</span><span class="p">;</span>
  <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;revise same semantic lights&quot;</span><span class="p">;</span>
  <span class="n">ReviseLights</span><span class="p">(</span><span class="n">lights</span><span class="p">,</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">light_ids</span><span class="p">,</span> <span class="n">cur_color</span><span class="p">);</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SemanticTable</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">iter</span> <span class="o">=</span>
      <span class="n">std</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">history_semantic_</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">history_semantic_</span><span class="p">),</span>
                   <span class="n">boost</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">compare</span><span class="p">,</span> <span class="n">_1</span><span class="p">,</span> <span class="n">semantic_table</span><span class="p">));</span>

  <span class="c1">// 找相同 ID 的灯历史 revise_time_s_ （1.5 秒）内的颜色</span>
  <span class="c1">// 如果当前颜色是黑灯或者 unknown，直接用历史颜色赋值</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">iter</span> <span class="o">!=</span> <span class="n">history_semantic_</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">pre_color</span> <span class="o">=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">time_stamp</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">&lt;</span> <span class="n">revise_time_s_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;revise by time series&quot;</span><span class="p">;</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">cur_color</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="nl">TL_YELLOW</span><span class="p">:</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_RED</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">ReviseLights</span><span class="p">(</span><span class="n">lights</span><span class="p">,</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">light_ids</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">);</span>
            <span class="n">iter</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">time_stamp</span><span class="p">;</span>
            <span class="n">iter</span><span class="o">-&gt;</span><span class="n">hystertic_window</span><span class="p">.</span><span class="n">hysteretic_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">UpdateHistoryAndLights</span><span class="p">(</span><span class="n">semantic_table</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
            <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;High confidence color &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s_color_strs</span><span class="p">[</span><span class="n">cur_color</span><span class="p">];</span>
          <span class="p">}</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="nl">TL_RED</span><span class="p">:</span>
        <span class="k">case</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="nl">TL_GREEN</span><span class="p">:</span>
          <span class="n">UpdateHistoryAndLights</span><span class="p">(</span><span class="n">semantic_table</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">time_stamp</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">last_bright_time_stamp</span> <span class="o">&gt;</span> <span class="n">blink_threshold_s_</span> <span class="o">&amp;&amp;</span>
              <span class="n">iter</span><span class="o">-&gt;</span><span class="n">last_dark_time_stamp</span> <span class="o">&gt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">last_bright_time_stamp</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">iter</span><span class="o">-&gt;</span><span class="n">blink</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
          <span class="p">}</span>
          <span class="n">iter</span><span class="o">-&gt;</span><span class="n">last_bright_time_stamp</span> <span class="o">=</span> <span class="n">time_stamp</span><span class="p">;</span>
          <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;High confidence color &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">s_color_strs</span><span class="p">[</span><span class="n">cur_color</span><span class="p">];</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="nl">TL_BLACK</span><span class="p">:</span>
          <span class="n">iter</span><span class="o">-&gt;</span><span class="n">last_dark_time_stamp</span> <span class="o">=</span> <span class="n">time_stamp</span><span class="p">;</span>
          <span class="n">iter</span><span class="o">-&gt;</span><span class="n">hystertic_window</span><span class="p">.</span><span class="n">hysteretic_count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_UNKNOWN_COLOR</span> <span class="o">||</span>
              <span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_BLACK</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">iter</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">time_stamp</span><span class="p">;</span>
            <span class="n">UpdateHistoryAndLights</span><span class="p">(</span><span class="n">semantic_table</span><span class="p">,</span> <span class="n">lights</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iter</span><span class="p">);</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">ReviseLights</span><span class="p">(</span><span class="n">lights</span><span class="p">,</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">light_ids</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="nl">TL_UNKNOWN_COLOR</span><span class="p">:</span>
        <span class="k">default</span><span class="o">:</span>
          <span class="n">ReviseLights</span><span class="p">(</span><span class="n">lights</span><span class="p">,</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">light_ids</span><span class="p">,</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">);</span>
          <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">iter</span><span class="o">-&gt;</span><span class="n">time_stamp</span> <span class="o">=</span> <span class="n">time_stamp</span><span class="p">;</span>
      <span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">=</span> <span class="n">cur_color</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// set blink status</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pre_color</span> <span class="o">!=</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">||</span>
        <span class="n">fabs</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">last_dark_time_stamp</span> <span class="o">-</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">last_bright_time_stamp</span><span class="p">)</span> <span class="o">&gt;</span>
            <span class="n">non_blink_threshold_s_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">iter</span><span class="o">-&gt;</span><span class="n">blink</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="nl">index</span> <span class="p">:</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">light_ids</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">lights_ref</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">status</span><span class="p">.</span><span class="n">blink</span> <span class="o">=</span>
          <span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">blink</span> <span class="o">&amp;&amp;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span> <span class="o">==</span> <span class="n">base</span><span class="o">::</span><span class="n">TLColor</span><span class="o">::</span><span class="n">TL_GREEN</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;semantic &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">semantic</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; color &quot;</span>
           <span class="o">&lt;&lt;</span> <span class="n">s_color_strs</span><span class="p">[</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">color</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; blink &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">iter</span><span class="o">-&gt;</span><span class="n">blink</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; cur &quot;</span>
           <span class="o">&lt;&lt;</span> <span class="n">s_color_strs</span><span class="p">[</span><span class="n">cur_color</span><span class="p">];</span>
    <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cur ts &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">time_stamp</span><span class="p">);</span>
    <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;bri ts &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">last_bright_time_stamp</span><span class="p">);</span>
    <span class="n">ADEBUG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;dar ts &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">iter</span><span class="o">-&gt;</span><span class="n">last_dark_time_stamp</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">semantic_table</span><span class="p">.</span><span class="n">last_dark_time_stamp</span> <span class="o">=</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">time_stamp</span><span class="p">;</span>
    <span class="n">semantic_table</span><span class="p">.</span><span class="n">last_bright_time_stamp</span> <span class="o">=</span> <span class="n">semantic_table</span><span class="p">.</span><span class="n">time_stamp</span><span class="p">;</span>
    <span class="n">history_semantic_</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">semantic_table</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 Yilin Gui.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-12-01 19:33:51</p>
      </span>
    </div>

    
    
  </body>
</html>