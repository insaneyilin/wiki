<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>< 程序员的自我修养 > 读书笔记 - Yilin's Wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          <!--$表示行内元素，$$表示块状元素 -->
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <!--Mermaid流程图-->
    <script src="https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#reading_notes">reading_notes</a>&nbsp;&#187;&nbsp;< 程序员的自我修养 > 读书笔记
    <span class="updated">Page Updated&nbsp;
      2019-11-26 01:01
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">< 程序员的自我修养 > 读书笔记</div>

  <p>程序员的自我修养 -- 链接、装载与库</p>
<blockquote>
<p>程序员可以不自己造轮子，但是对轮子的构造了解的越详细越好，这就是程序员的自我修养吧。</p>
</blockquote>
<p>学习偏底层的知识可能无法对日常的学习工作产生直接的影响，但会带来潜移默化的帮助：</p>
<ul>
<li>当你的程序无法启动时</li>
<li>当你的代码链接失败时</li>
<li>当你的代码发生“段错误”时</li>
</ul>
<p>技术优劣取决于需求。</p>
<p>基本功永不过时。</p>
<div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#ch1">ch1 温故而知新</a></li>
<li><a href="#ch2">ch2 编译和链接</a></li>
<li><a href="#ch3">ch3 目标文件里有什么</a></li>
<li><a href="#ch4">ch4 静态链接</a></li>
</ul>
</div>
<hr />
<h2 id="ch1">ch1 温故而知新</h2>
<p>计算机软硬件基本结构。</p>
<p>硬件的关键部件：</p>
<ul>
<li>CPU</li>
<li>内存</li>
<li>IO 设备</li>
</ul>
<p>CPU频率低 -&gt; CPU 倍频 -&gt; 多核 CPU。</p>
<p>早期计算机没有复杂的图形功能，CPU核心频率不高，等于内存的频率，因而它们都直接连接在一根总线（Bus）上。</p>
<p>北桥，南桥。</p>
<p>随着技术的发展，CPU频率有了很大的提升，加上图形功能的要求，此时CPU频率是内存频率的倍数，内存频率跟不上而保持与总线频率一致，CPU以倍频方式与总线进行通信。3D游戏和多媒体的发展促使了图形芯片的诞生，而图形芯片需要CPU和内存之间大量交换数据，I/O总线实在太慢，人们因而设计了高速的北桥芯片方便高速交换数据。</p>
<p>北桥运行速度高，如果低速设备也直接连在北桥，无疑会造成非常复杂的设计。因而引入南桥专门处理低速设备。</p>
<p>通过增加CPU数量来提升速度，也就是多核CPU。</p>
<p>硬件处理能力是有限的，操作系统需要做的，就是除了提供抽象接口之外，管理硬件资源。</p>
<p>硬件的抽象，在 UNIX 系统中，访问硬件同访问文件方式一样。</p>
<p>文件系统。磁盘存储方式。物理扇区，逻辑扇区。</p>
<p>不能让 CPU 一次只能运行一个程序 -&gt; 多任务(multi-tasking)系统：</p>
<ol>
<li>每个应用程序都以进程(Process)的方式运行。</li>
<li>每个进程有自己独立的地址空间，进程之间的地址空间相互隔离</li>
<li>CPU 由系统根据进程优先级高低统一分配</li>
<li>抢占式(Preemptive)的 CPU 分配机制可以让系统强制剥夺 CPU 资源并分配给它认为目前最需要的进程</li>
</ol>
<p>如果分配给每个进程的时间都很短，CPU 在多个进程间快速的切换，就能造成很多进程同时运行的假象。</p>
<p>如何将计算机的物理内存分配给多个程序使用。增加中间层，使用间接的地址访问方法。</p>
<p>进程 -&gt; 虚拟地址（中间层） -&gt; 物理地址。</p>
<p>分段（Segmentation）：基本思路就是程序需要多少内存，就设置多大的虚拟内存并映射到某个物理地址空间，只要程序访问虚拟空间的地址超出了设置的内存大小，硬件自动判断为非法访问，拒绝请求。这样它实现了地址隔离，同时程序不需要重定位，不需要关心物理地址的变化（因为只需要按照虚拟空间的内存分配来编写程序）。没有解决内存使用效率不高的问题。分段对内存区域的映射还是按照程序为单位，如果内存不足，依然会以整个程序为单位进行换入换出，造成大量磁盘访问操作从而严重影响速度。</p>
<p>分页（Paging）：分页的就是把地址空间人为地等分成固定的页，以页为单位进行数据的存取和交换。通过一个叫MMU（Memory Management Unit）的部件来实现页映射。</p>
<p>线程，轻量级进程。程序执行流的最小单元。</p>
<p>一个进程包含多个线程，每个线程由线程ID、当前指令指针（PC）、寄存器集合和堆栈组成，各个线程之间共享程序的内存空间和进程级的资源，同时又互不干扰的并发执行。</p>
<p>多线程比多进程更自由；相对于多进程，多线程在数据共享方面效率高很多。</p>
<p>在线程调度中，线程至少有三种状态：</p>
<ul>
<li>运行 Running，此时线程正在执行</li>
<li>就绪 Ready，此时线程可以立刻运行，但 CPU 已经被占用</li>
<li>等待 Waiting，此时线程正在等待某一事件（通常是 I/O 或同步），无法执行</li>
</ul>
<p>线程调度：优先级调度，轮转法。</p>
<ul>
<li>I/O 密集型线程：频繁等待。</li>
<li>计算密集型线程：很少等待。</li>
</ul>
<p>IO 密集型更容易得到优先级提升。</p>
<p>Linux 将所有执行实体（无论是进程还是线程）都称为任务（Task），不同任务可以选择共享内存空间。实际意义上，多个共享内存空间的任务组成了一个进程，这里面每个任务也就是这个进程里的线程。</p>
<p>Linux 中通过 fork 复制当前进程。</p>
<p>线程安全，保证共享数据在多线程并发时的一致性。</p>
<p>原子操作，单指令，线程安全，但只适用于简单的场景。</p>
<p>同步与锁。</p>
<p>同步，就是一个线程还没访问完一个数据，其他线程不能再对该数据进行访问，从本质上讲，保证了对数据的访问是原子化的。</p>
<p>锁是一种常见的同步机制，每个线程在访问数据前先 acquire 锁，访问结束后 release 锁；在锁已经被占用的时候试图获取锁时，线程会等待，直到锁被释放。</p>
<p>二元信号量（Binary Semaphore），只有两种状态：占用和非占用。占用时其他线程无法获取锁，直到被释放转为非占用。非占用时第一个线程自然可以获取锁。</p>
<p>如果资源能够允许多个线程并发访问，那就是多元信号量（Semaphore）。显然二元信号量是特殊情况。一个初始值为N的信号量允许N个线程并发访问：</p>
<div class="hlcode"><pre><span></span><span class="o">--</span><span class="nv">semaphore</span><span class="c1">;</span>
<span class="k">if</span> <span class="ss">(</span><span class="nv">semaphore</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="ss">)</span> {
  <span class="nv">current</span> <span class="nv">thread</span> <span class="nv">waiting</span><span class="c1">;</span>
} <span class="k">else</span> {
  继续执行，访问完资源后，释放信号量
  <span class="o">++</span><span class="nv">semaphore</span><span class="c1">;</span>
  <span class="k">if</span> <span class="ss">(</span><span class="nv">semaphore</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="ss">)</span> {
    唤醒一个等待中的线程
  }
}
</pre></div>


<p>互斥锁（Mutex）：类似二元信号量，区别在于其要求哪个线程获取了 mutex，哪个线程就要负责释放它。</p>
<p>读写锁（Read-Write Lock）：对于读次数 &gt;&gt; 写次数的情况适用。</p>
<p>条件变量（Condition Variable）：实现事件通知机制。一个条件变量可以被多个线程等待。当某个事件发生时，条件变量被唤醒，可以通知其他线程恢复执行。</p>
<p>多线程模型（线程的实际并发执行是由操作系统完成的）：</p>
<ul>
<li>一对一</li>
<li>多对一</li>
<li>多对多</li>
</ul>
<p>（这里的 X 对 X 指的是 User Thread 和 Kernel Thread 的对应，注意这里的 Kernel Thread 不是 linux 内核里的 kernel_thread）</p>
<hr />
<h2 id="ch2">ch2 编译和链接</h2>
<p>IDE 往往提供的 Build （构建）功能，实际包括编译和链接。</p>
<ul>
<li>预处理：展开预编译指令，比如"#include", "#define"等</li>
<li>编译：包括词法分析、语法分析、语义分析，优化后生成汇编代码文件</li>
<li>汇编：将汇编代码转变成机器指令</li>
<li>链接：将目标文件链接起来生成最终的可执行文件</li>
</ul>
<p>预编译，生成 .i 文件</p>
<div class="hlcode"><pre><span></span><span class="n">gcc</span> <span class="o">-</span><span class="n">E</span> <span class="n">hello</span><span class="p">.</span><span class="k">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span><span class="p">.</span><span class="n">i</span>
</pre></div>


<p>编译：</p>
<div class="hlcode"><pre><span></span><span class="n">gcc</span> <span class="o">-</span><span class="n">S</span> <span class="n">hello</span><span class="p">.</span><span class="n">i</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span><span class="p">.</span><span class="n">S</span>
</pre></div>


<p>现代版本的 GCC 把预编译和编译合并成一个步骤，使用 <code>cc1</code> 程序完成：</p>
<div class="hlcode"><pre><span></span><span class="n">cc1</span> <span class="n">hello</span><span class="p">.</span><span class="k">c</span>
</pre></div>


<p>gcc 这个命令是各种后台程序的包装（cc1, 汇编器 as，链接器 ld）。</p>
<p>汇编：</p>
<div class="hlcode"><pre><span></span><span class="n">gcc</span> <span class="o">-</span><span class="k">c</span> <span class="n">hello</span><span class="p">.</span><span class="k">c</span> <span class="o">-</span><span class="n">o</span> <span class="n">hello</span><span class="p">.</span><span class="n">o</span>
</pre></div>


<p>链接：</p>
<div class="hlcode"><pre><span></span><span class="n">ld</span> <span class="o">-</span><span class="k">static</span> <span class="n">crt1</span><span class="p">.</span><span class="n">o</span> <span class="n">crti</span><span class="p">.</span><span class="n">o</span> <span class="p">......</span>
</pre></div>


<p>实际链接了一大堆东西。</p>
<p>人们把每个源代码模块独立地编译，然后按照须要将它们"组装"起来，这个组装模块的过程就是链接（Linking）。</p>
<p>编译器是什么？一个将高级语言翻译成机器语言的工具。</p>
<p>链接器的年龄比编译器长。</p>
<p>链接过程主要包括了地址和空间分配（Address and Storage Allocation）、符号决议（Symbol Resolution）和重定位（Relocation）等这些步骤。</p>
<p>符号决议有时候也被叫做符号绑定（Symbol Binding）、名称绑定（Name Binding）、名称决议（Name Resolution），甚至还有叫做地址绑定（Address Binding）、指令绑定（Instruction Binding）的，大体上它们的意思都一样，但从细节角度来区分，它们之间还是存在一定区别的，比如"决议"更倾向于静态链接，而"绑定"更倾向于动态链接，即它们所使用的范围不一样。在静态链接，我们将统一称为符号决议。</p>
<p>重定位（Relocation）：重新计算各个目标的地址的过程。</p>
<p>若引用其他文件中的变量，在将该文件编译成目标文件时，先将该变量目标地址置为0，等待链接再将该地址进行修正。这个地址修正的过程也被叫做重定位（Relocation），每个要被修正的地方叫一个重定位入口（Relocation Entry）。重定位所做的就是给程序中每个这样的绝对地址引用的位置"打补丁"，使它们指向正确的地址。</p>
<p>符号(Symbol)这个概念随着汇编语言的普及迅速被使用，它用来表示一个地址，这个地址可能是一段子程序(后来发展成函数)的起始地址，也可以是一个变量的起始地址。</p>
<p>模块之间如何组合的问题可以归结为模块之间如何 <strong>通信</strong> 的问题。通信方式：函数调用，变量访问，都需要知道相应的地址。模块间通过符号引用来实现通信，也就是要找到对应的地址。</p>
<h2 id="ch3">ch3 目标文件里有什么</h2>
<p>目标文件（<em>.o 或 </em>.obj），从结构上来说，它就是编译后的 <strong>可执行文件格式</strong> ，只是还没有经过链接，其中 <strong>可能有些符号地址还没有被调整</strong> 。</p>
<p>可执行文件格式，Windows 下 PE(Portable Executable)和 Linux 下的 ELF(Executable Linkable Format)。它们都是 COFF (Common file format) 的变种。</p>
<ul>
<li>可重定位文件：.o / .obj</li>
<li>可执行文件：/bin/bash 或 .exe</li>
<li>共享目标文件：dll 或 so</li>
<li>核心转储文件：core dump，当进程意外终止时，系统将进程的地址空间的内容和终止时的其他一些信息保存下来</li>
</ul>
<p>Linux下命令： <code>file &lt;filename&gt;</code>  显示出对应文件的类型</p>
<p>目标文件包含的内容：编译后的机器指令代码、数据，还有链接时要的一些信息（比如符号表、调试信息、字符串等）。</p>
<p>一般目标文件把上述信息按不同的属性，以节（section）的形式存储。有时也叫段（segment）</p>
<p>代码段常见的名字有 “.code”  “.text”，编译后的机器指令就放在代码段。</p>
<p>数据段：一般名字都是 “.data”，已初始化全局变量和局部静态变量数据放在这里。</p>
<p>ELF文件的开头是一个”文件头”，它描述了整个文件的文件属性（是否可读可写可执行，是静态链接还是动态链接及入口地址）、目标硬件、目标操作系统等信息。</p>
<p>文件头还有一个段表（section table）。描述文件各个段的数组（各个段在文件中的偏移和属性）。</p>
<p>关于bss段：未初始化的全局变量和静态局部变量一般放在一个”.bss”段的地方。它只是为未初始化的全局变量和静态局部变量预留位置而已，并没有内容，在文件中不占空间。</p>
<p>总体来说：程序源代码被编译后主要分成两种段：<strong>程序指令</strong>（代码段），<strong>程序数据</strong>（数据段，bss段）。</p>
<p><strong>为什么要将程序指令和程序数据分开放？</strong></p>
<ul>
<li>数据和指令分别映射到虚存，区分只读和读写属性</li>
<li><strong>提高程序的局部性</strong>，有利于 CPU 的缓存（cache）提高命中率</li>
<li>实现了“共享指令”，可以节省大量内存</li>
</ul>
<p><code>objdump</code> 查看各种目标文件的结构和内容， <code>objdump –h main.o  -h</code> 表示把ELF文件的各个段的基本信息打出来</p>
<p><code>readelf</code> -- 专门针对ELF文件格式的解析器</p>
<p>ELF文件结构：</p>
<ul>
<li>文件头<ul>
<li>ELF魔数：文件头最开始的4个字节是所有ELF都必须相同的标识码。又称为魔数。用来确认文件类型，操作系统在加载可执行文件的时候会确认魔数是否正确，若不正确则拒绝加载。</li>
<li>ELF文件类型：分为可重定位、可执行、共享目标文件、核心转储文件</li>
</ul>
</li>
<li>段表<ul>
<li>描述了ELF各个段的信息（比如每个段的段名、段的长度、在文件中的偏移，读写权限及其他属性）</li>
<li>编译器、链接器和装载器都是靠段表来定位和访问各个段的属性的。</li>
</ul>
</li>
<li>重定位表<ul>
<li>链接器在处理目标文件时，需要对目标文件中的某些部位进行重定位（即代码段和数据段中那些对绝对地址的引用的位置）。</li>
<li>这些重定位信息都记录在ELF文件的重定位表里。对于每个需要重定位的代码段或数据段，都会有一个相应的重定位表。</li>
</ul>
</li>
<li>字符串表<ul>
<li>把ELF文件中用到的字符串（段名、变量名等）集中起来存放到一个表中。然后使用字符串在表中的偏移来引用字符串。这个表就是字符串表。</li>
</ul>
</li>
</ul>
<p>链接的接口 -- 符号（Symbol）：</p>
<ul>
<li>链接过程的本质就是要把多个不同的目标文件之间相互粘滞到一起。</li>
<li>为了使不同目标文件之间能够相互粘合，这写目标文件必须要有固定的规则才行。</li>
<li>在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。</li>
<li>在链接中，我们将函数和变量统称为符号（symbol），函数名或变量名就是符号名（symbol name）。</li>
<li>每一个目标文件都会有一个相应的符号表（symbol table），记录着目标文件中所用到的所有的符号。</li>
<li>每个定义的符号有一个对应的值叫做符号值（symbol value）。对于变量或函数来说，符号值就是它们的地址。</li>
</ul>
<p>特殊符号：ld链接器产生可执行文件时，会给我们定义很多符号（没有在自己的程序中定义），但是可以直接声明并且引用它，我们称之为特殊符号。</p>
<p>符号修饰与函数签名：c++增加了名称空间（namespace）的方法来解决多模块之间的符号冲突问题。c++为了与c兼容，在符号的管理上，c++有一个用来声明或定义一个C的符号extern”C”的关键字用法，可以让c++的名称修饰机制不作用。</p>
<p>弱符号与强符号，弱引用与强引用。弱符号和弱引用对库来说非常有用，比如库中定义的弱符号可以被用户定义的强符号所覆盖。</p>
<p>调试信息：在gcc编译时加上 <code>-g</code> 参数就会在产生的目标文件里面加上调试信息。目标文件会多一些 debug 段。</p>
<hr />
<h2 id="ch4">ch4 静态链接</h2>
<p>空间地址分配有按序叠加和相似段合并两种方法，一般都使用相似段合并的方法。最后的可执行文件当中包含了可重定位的.o文件里面的所有指令。</p>
<p>按序叠加会导致有很多零散的段，非常浪费空间。对于 x86 的硬件，段的装载地址和空间的对齐单位是页，即 4096 字节，如果按序叠加，即使一个段只有 1 个字节，也需要占用 4096 字节。</p>
<p>现代链接器一般使用两步链接：</p>
<ul>
<li>空间与地址分配</li>
<li>符号解析与重定位</li>
</ul>
<p>为什么需要重定位？</p>
<p>指令位置分类：</p>
<ul>
<li>位置无关编码(PIC)：汇编源文件被编码成二进制可执行程序时编码方式与位置(内存地址)无关</li>
<li>位置相关编码：汇编源文件被编码成二进制可执行程序时编码方式与位置(内存地址)相关</li>
</ul>
<p>在程序设计编译链接过程会给程序一个运行地址，而且必须给编译连接器指定这个地址，最后得到的二进制程序是和指定的链接地址相关的，这个地址叫做”链接地址”。所以我们在程序编译时其实就已经知道程序将来运行时的地址，这个地址叫做”运行地址”，运行地址和链接地址相关，但是不一定是同一个，程序执行时必须放在指定的链接地址下，否则不能运行，这些程序指令就是位置相关代码。</p>
<p>链接地址和运行地址有时候不能相同，而且不能全部使用位置无关指令，则需要重定位来解决该问题。</p>
<p>在位置无关代码执行完毕之前和位置相关代码开始之前，必须将代码搬移到链接地址上去，否则后面的位置相关代码将会出错，所以才需要进行重定位。</p>
<p>符号解析。我们目标文件中用到的符号可能被定义在其他目标文件，所以要将目标文件链接起来。最常见的错误之一：undefined symbol，就是链接时符号未定义，一般是链接时缺少某个库。</p>
<p>重复代码消除，例如 C++ 的模板技术使得模板 <strong>可以在多个源文件中分别实例化</strong> 但是编译器并不能知道它在多处被同一种数据类型实例化，所以现在主流编译器例如GNU 的做法是在每一个目标文件中对于一个模板的同一种实例化使用一种相同的名称，这样在链接阶段，链接器会检查这些重复的段并只保留一份。</p>
<p>函数级别链接: 通常的链接过程都是文件或者编译单元级别的链接，但是当只需要使用某个目标为见中的一个函数或变量的时候，就需要全部包含该文件，导致体积很大，编译器为此专门提供了函数级别的链接，与重复代码消除和相似，编译器将所有函数都想模板函数一样单独保存到一个段中，需要的时候再将其包含到输出文件，其他的则直接抛弃，这虽然较小的最终文件的体积但是由于段的数目增减，减慢了编译和链接的过程。GCC使用 <code>-fdata-sections</code> 和 <code>-ffunction-sections</code> 可以将变量或者函数分别保存到独立的段中。</p>
<p>全局构造与析构: 全局对象的构造在main函数之前执行，全局对象的析构在main函数之后哦执行，Linux下的入口函数是 <code>_start</code> ,用于在main执行前进行初始化。</p>
<p>为了 <strong>使得不同平台的目标文件兼容，即可以相互链接</strong> ，这些文件必须有一致的ABI(Application Binary Interface),即二进制兼容，ABI内容包括符号修饰标准，变量内存布局，函数调用方式等等。厂商不希望用户看见自己的源代码所以会提供二进制版本，所以二进制兼容在大型项目中变得很重要。</p>
<p>API 和 ABI 的区别，API 描述源代码级别的接口，ABI 描述二进制级别的接口。比如，C++ 对象内存布局（Object Memory Layou）是 C++ ABI 的一部分。</p>
<p>ABI 的存在意义：人们一直希望不用修改代码就能实现程序的重用。</p>
<p>C++ 一直为人诟病的一大原因就是其 ABI 兼容性差。</p>
<p>静态库：可以看成一组目标文件的集合。</p>
<p>一个静态库文件（.a）是由许多.o文件合并而来的，linux下使用 <code>ar -t xx.a</code> 可以查看 .a 文件中包含的 .o 文件。</p>
<p>链接过程控制，有链接控制脚本。</p>
<p>BFD（Binary File Descriptor libary）库：是基于所有硬件平台（不同的处理器和目标文件格式）的一个抽象层，基于BFD可以不用关心具体的硬件格式，而进行统一操作，因为BFD中已经包含了这些CPU和可执行文件的格式信息。BFD 本身是 binutils 项目的一个子项目。</p>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 Yilin Gui.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-11-30 03:05:19</p>
      </span>
    </div>

    
    
  </body>
</html>