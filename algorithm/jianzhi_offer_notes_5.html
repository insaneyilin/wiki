<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>剑指offer笔记(5) - Yilin's Wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          <!--$表示行内元素，$$表示块状元素 -->
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <!--Mermaid流程图-->
    <script src="https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#algorithm">algorithm</a>&nbsp;&#187;&nbsp;剑指offer笔记(5)
    <span class="updated">Page Updated&nbsp;
      2019-07-13 01:34
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">剑指offer笔记(5)</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#6">第 6 章 面试中的各种能力</a><ul>
<li><a href="#38">面试题38：数字在排序数组中出现的次数。</a></li>
<li><a href="#39">面试题39：二叉树的深度</a></li>
<li><a href="#39-2">面试题39-2：判断平衡二叉树</a></li>
<li><a href="#40">面试题40：数组中只出现一次的数字</a></li>
<li><a href="#41-s">面试题41：和为 S 的两个数字</a></li>
<li><a href="#41-2s">面试题41-2：和为S的连续正数序列</a></li>
<li><a href="#42">面试题42：翻转单词顺序</a></li>
<li><a href="#42-2">面试题42-2：字符串的左旋转</a></li>
<li><a href="#_1">抽象建模能力</a><ul>
<li><a href="#43n">面试题43：n 个骰子的点数</a></li>
<li><a href="#44">面试题44：扑克牌的顺子</a></li>
<li><a href="#45">面试题45：圆圈中最后剩下的数字（约瑟夫环）</a></li>
</ul>
</li>
<li><a href="#_2">发散思维能力</a><ul>
<li><a href="#46-12n">面试题46：求 1+2+...+n</a></li>
<li><a href="#47">面试题47：不用加减乘除做加法</a></li>
<li><a href="#48">面试题48：不能被继承的类</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<p><a href="https://book.douban.com/subject/27008702/">《剑指Offer》</a> 读书笔记。</p>
<h2 id="6">第 6 章 面试中的各种能力</h2>
<ul>
<li>沟通能力。题目的细节，主动提问。</li>
<li>表达能力。</li>
<li>学习能力。</li>
<li>应变能力。</li>
</ul>
<p>面试是一个双向交流的过程。</p>
<p>例子，找出第 1500 个丑数。可以针对丑数定义提问。有些面试官故意不把信息给全。</p>
<p>在解题前要搞清楚面试官的意图。</p>
<p>知识迁移能力。”举一反三“，连续几个问题，由易到难。</p>
<h4 id="38">面试题38：数字在排序数组中出现的次数。</h4>
<blockquote>
<p>统计一个数字在排序数组中出现的次数。例如输入数组 {1, 2, 3, 3, 3, 3, 4, 5} 和数字 3，数字 3 在数组中出现了 4 次，输出 4。</p>
</blockquote>
<p>输入的数组是有序的，自然想到能够利用二分查找。</p>
<p>偷懒的做法，直接用 C++ 的 lower_bound 和 upper_bound 函数。</p>
<ul>
<li>lower_bound 返回非递减序列中第一个大于等于 val 的元素位置</li>
<li>upper_bound 返回非递减序列中第一个大于 val 的元素位置</li>
</ul>
<p>自己实现 upper_bound 和 lower_bound。首先分析 lower_bound，即在数组中找到第一个 k 出现的位置。二分查找总是先拿数组中间的数字和 k 作比较。如果中间的数字比 k 大，那么 k 只有可能出现在数组的前半段，下一轮只在前半段查找。如果中间的数字比 k 小，那么 k 只可能出现在数组的后半段。如果中间的数字等于 k ？此时要看中间数字的前一个数字，如果前一个不是 k ，则中间数字就是第一个 k，否则继续在前半段中查找。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">GetNumberOfK</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">get_end_k</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span> <span class="o">-</span> <span class="n">get_start_k</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">k</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="c1">// 返回 [left, right] 中第一个 k 出现的位置</span>
    <span class="kt">int</span> <span class="n">get_start_k</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&gt;</span> <span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 返回 [left, right] 中最后一个 k 后一个位置</span>
    <span class="kt">int</span> <span class="n">get_end_k</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">data</span><span class="p">,</span> <span class="kt">int</span> <span class="n">k</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">left</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right</span> <span class="o">=</span> <span class="n">data</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">left</span> <span class="o">&lt;=</span> <span class="n">right</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">mid</span> <span class="o">=</span> <span class="p">(</span><span class="n">left</span> <span class="o">+</span> <span class="n">right</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="n">data</span><span class="p">[</span><span class="n">mid</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">right</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">left</span> <span class="o">=</span> <span class="n">mid</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">left</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>上面的实现很巧妙，合并了 <code>k == data[mid]</code> 的情况。不放心的话每次判断的时候可以单独判断 <code>k == data[mid]</code> 。</p>
<p>二分查找非常容易写错， while 里的条件不同，left、right 定义不同，则 if 中的 left、right 更新方式都不同。最好好好整理一下二分查找的各种实现。</p>
<h4 id="39">面试题39：二叉树的深度</h4>
<blockquote>
<p>给定一个二叉树，找出其最大深度。二叉树的深度为根节点到最远叶子节点的距离。</p>
</blockquote>
<p>直接根据二叉树的递归定义来做：</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/**</span>
<span class="cm">    * @param root: The root of binary tree.</span>
<span class="cm">    * @return: An integer</span>
<span class="cm">    */</span>
    <span class="kt">int</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// write your code here</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">maxDepth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h4 id="39-2">面试题39-2：判断平衡二叉树</h4>
<blockquote>
<p>平衡二叉树任意节点的左右子树深度相差不超过 1 。</p>
</blockquote>
<p>利用上面求二叉树深度的代码可以迅速写出如下的代码：</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">IsBalanced_Solution</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">left_depth</span> <span class="o">=</span> <span class="n">tree_depth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">right_depth</span> <span class="o">=</span> <span class="n">tree_depth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">left_depth</span> <span class="o">-</span> <span class="n">right_depth</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="k">return</span> <span class="nf">IsBalanced_Solution</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">IsBalanced_Solution</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">tree_depth</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">max</span><span class="p">(</span><span class="n">tree_depth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span> <span class="n">tree_depth</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>缺点是需要重复遍历同一节点多次（求每个节点对应子树的深度时会重复遍历一些节点），效率不高。</p>
<p>如何优化使得每个节点只被遍历一次？利用后序遍历。后序遍历二叉树，在遍历某个节点的左右子树之后，可以根据其左右子树的深度判断它是不是平衡的，同时得到当前节点的深度。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">IsBalanced_Solution</span><span class="p">(</span><span class="n">TreeNode</span><span class="o">*</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">return</span> <span class="nf">is_balanced</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">depth</span><span class="p">);</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kt">bool</span> <span class="n">is_balanced</span><span class="p">(</span><span class="n">TreeNode</span> <span class="o">*</span><span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">depth</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">root</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">int</span> <span class="n">left_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">right_depth</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">is_balanced</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">,</span> <span class="n">left_depth</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">is_balanced</span><span class="p">(</span><span class="n">root</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">,</span> <span class="n">right_depth</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">abs</span><span class="p">(</span><span class="n">left_depth</span> <span class="o">-</span> <span class="n">right_depth</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> 
            <span class="p">{</span>
                <span class="n">depth</span> <span class="o">=</span> <span class="n">max</span><span class="p">(</span><span class="n">left_depth</span><span class="p">,</span> <span class="n">right_depth</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
                <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>求二叉树深度 -&gt; 判断平衡二叉树。考察知识迁移能力。</p>
<h4 id="40">面试题40：数组中只出现一次的数字</h4>
<blockquote>
<p>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。</p>
</blockquote>
<p>要求只遍历一次，使用常数空间。</p>
<p>异或运算：任何一个数异或它自己都等于 0；任何一个数异或 0 都等于它自己。</p>
<h4 id="41-s">面试题41：和为 S 的两个数字</h4>
<blockquote>
<p>输入一个递增排序的数组和一个数字S，在数组中查找两个数，使得他们的和正好是S，如果有多对数字的和等于S，输出两个数的乘积最小的。 </p>
</blockquote>
<p>O(n^2) 的方法，先在数组中固定一个数字，再依次判断数组中其余的 n-1 个数字与它的和是不是等于 S。</p>
<p>两指针解法，头尾向中间求和。和比 S 小，头向中间移，和比 S 大，尾向中间移。</p>
<p>如果输入的数组不是有序的，先排序即可。</p>
<h4 id="41-2s">面试题41-2：和为S的连续正数序列</h4>
<blockquote>
<p>小明很喜欢数学,有一天他在做数学作业时,要求计算出9~16的和,他马上就写出了正确答案是100。但是他并不满足于此,他在想究竟有多少种连续的正数序列的和为100(至少包括两个数)。没多久,他就得到另一组连续正数和为100的序列:18,19,20,21,22。现在把问题交给你,你能不能也很快的找出所有和为S的连续正数序列? Good Luck! </p>
<p>输入一个正数 S，打印出所有和为 S 的连续正数序列（至少含两个数）。</p>
</blockquote>
<p>沿着题目1的思路思考，可以使用两指针。用 small 和 big 分别表示连续序列的最小值和最大值。首先把 small 初始化为 1，big 初始化为 2。如果从 small 到 big 的序列和小于 S。我们可以增大 big。让这个序列包含更多的数字。因为这个序列至少要有两个数字，我们一直增加 small 到 (S + 1) / 2 为止。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">FindContinuousSequence</span><span class="p">(</span><span class="kt">int</span> <span class="n">sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">small</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">big</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">half_sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">small</span> <span class="o">&lt;</span> <span class="n">half_sum</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">seq_sum</span> <span class="o">=</span> <span class="n">sequence_sum</span><span class="p">(</span><span class="n">small</span><span class="p">,</span> <span class="n">big</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">seq_sum</span> <span class="o">==</span> <span class="n">sum</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">gen_sequence</span><span class="p">(</span><span class="n">small</span><span class="p">,</span> <span class="n">big</span><span class="p">));</span>
                <span class="o">++</span><span class="n">small</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">seq_sum</span> <span class="o">&lt;</span> <span class="n">sum</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="o">++</span><span class="n">big</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="o">++</span><span class="n">small</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="kr">inline</span> <span class="kt">int</span> <span class="n">sequence_sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">small</span><span class="p">,</span> <span class="kt">int</span> <span class="n">big</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">small</span> <span class="o">+</span> <span class="n">big</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="n">big</span> <span class="o">-</span> <span class="n">small</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gen_sequence</span><span class="p">(</span><span class="kt">int</span> <span class="n">small</span><span class="p">,</span> <span class="kt">int</span> <span class="n">big</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">big</span> <span class="o">-</span> <span class="n">small</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">small</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>这段代码可以进行时间效率上的优化，注意 sequence_sum 求和会导致很多重复的数字被遍历。可以进行增量求和。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">FindContinuousSequence</span><span class="p">(</span><span class="kt">int</span> <span class="n">sum</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">small</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">big</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">half_sum</span> <span class="o">=</span> <span class="p">(</span><span class="n">sum</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">cur_sum</span> <span class="o">=</span> <span class="n">small</span> <span class="o">+</span> <span class="n">big</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">small</span> <span class="o">&lt;</span> <span class="n">half_sum</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">cur_sum</span> <span class="o">&lt;</span> <span class="n">sum</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="o">++</span><span class="n">big</span><span class="p">;</span>
                <span class="n">cur_sum</span> <span class="o">+=</span> <span class="n">big</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cur_sum</span> <span class="o">==</span> <span class="n">sum</span><span class="p">)</span>
                    <span class="n">res</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">gen_sequence</span><span class="p">(</span><span class="n">small</span><span class="p">,</span> <span class="n">big</span><span class="p">));</span>

                <span class="n">cur_sum</span> <span class="o">-=</span> <span class="n">small</span><span class="p">;</span>
                <span class="o">++</span><span class="n">small</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">gen_sequence</span><span class="p">(</span><span class="kt">int</span> <span class="n">small</span><span class="p">,</span> <span class="kt">int</span> <span class="n">big</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">(</span><span class="n">big</span> <span class="o">-</span> <span class="n">small</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">small</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h4 id="42">面试题42：翻转单词顺序</h4>
<blockquote>
<p>输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。标点符号当成普通字符处理。如 "I am a student." 翻转后为 "student. a am I"。</p>
</blockquote>
<p>思路是先将整个句子作为一个字符串翻转，再翻转每个单词。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">ReverseSentence</span><span class="p">(</span><span class="n">string</span> <span class="n">str</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">str</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">j</span><span class="p">);</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>加入以下条件：</p>
<ul>
<li>单词的构成：无空格字母构成一个单词</li>
<li>输入字符串是否包括前导或者尾随空格？可以包括，但是反转后的字符不能包括</li>
<li>如何处理两个单词间的多个空格？在反转字符串中间空格减少到只含一个</li>
</ul>
<p>则可以先以空格为 delimit 进行字符串分割，再反向连接（注意特殊情况的处理）：</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="cm">/**</span>
<span class="cm">    * @param s : A string</span>
<span class="cm">    * @return : A string</span>
<span class="cm">    */</span>
    <span class="n">string</span> <span class="n">reverseWords</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// write your code here</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">words</span> <span class="o">=</span> <span class="n">split</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="sc">&#39; &#39;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">words</span><span class="p">.</span><span class="n">rbegin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">words</span><span class="p">.</span><span class="n">rend</span><span class="p">(),</span> <span class="n">words</span><span class="p">.</span><span class="n">back</span><span class="p">(),</span> 
            <span class="p">[](</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">){</span>
                <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="sc">&#39; &#39;</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
        <span class="p">});</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">split</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delim</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">delim</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">);</span>
            <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">j</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="n">delim</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">)</span>
                <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="o">-</span> <span class="n">i</span><span class="p">));</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">j</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h4 id="42-2">面试题42-2：字符串的左旋转</h4>
<p>即经典的数组左移位问题。</p>
<p>"abcdefg" 左旋转 2 位得到 "cdefgab"。</p>
<p>从翻转单词顺序得到启发。"hello world" 翻转单词后得到 "world hello" ，很像是左移了一个单词 hello（不考虑空格）。</p>
<p>先分别翻转两部分，再翻转整个字符串。"abcdefg" -&gt; "bagfedc" -&gt; "cdefgab"</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">string</span> <span class="n">LeftRotateString</span><span class="p">(</span><span class="n">string</span> <span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">length</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
        <span class="n">n</span> <span class="o">%=</span> <span class="n">len</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span><span class="p">);</span>
        <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
        <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">str</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h3 id="_1">抽象建模能力</h3>
<ul>
<li>选择合理的数据结构来描述问题</li>
<li>分析模型中的内在规律</li>
</ul>
<h4 id="43n">面试题43：n 个骰子的点数</h4>
<blockquote>
<p>把 n 个骰子扔在地上，所有骰子朝上一面的点数之和为 s ，输入 n 打印出 s 的所有可能值出现的概率。</p>
</blockquote>
<p>骰子一共 6 个面，每个面对应 1 到 6 之间的一个数字。n 个骰子的点数和的最小值为 n，最大值为 6n。根据排列组合， n 个骰子的所有点数的排列数为 6^n。先统计出每一个点数和出现的次数，然后把每一个点数和出现的次数除以 6^n，就能求出每个点数出现的概率。</p>
<p>解法1：递归求点数和出现次数（时间效率低）</p>
<p>要想求出 n 个骰子的点数和，可以先把 n 个骰子分成两堆，第一堆只有一个，另一堆有 n - 1 个。单独的那一个有可能出现从 1 到 6 的点数。我们需要计算从 1 到 6 的每一个和剩下的 n-1 个骰子能够组成的点数和。对 n-1 个骰子继续递归。。。</p>
<p>点数和可能值为 [n, 6n]，定义一个长度为 6n - n + 1 的数组，和为 s 的点数出现的次数保存到数组的第 s - n 个元素中。</p>
<p>解法2：基于循环求点数和</p>
<p>考虑用两个数组来保存点数和的总数。在一次循环中，第一个数组中的第 n 个数字表示点数和为 n 出现的次数。在下一次循环中，我们加上一个新的骰子，此时和为 n 的骰子出现的次数应该等于上一次循环中点数和为 n-1, n-2, n-3, n-4, n-5, n-6 的次数的总和，所以我们把另一个数组的第 n 个数字设为前一个数组对应的第 n-1, n-2, n-3, n-4, n-5, n-6 之和。</p>
<div class="hlcode"><pre><span class="kt">int</span> <span class="n">g_max_value</span> <span class="o">=</span> <span class="mi">6</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">print_probility</span><span class="p">(</span><span class="kt">int</span> <span class="n">number</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">number</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">probabilities</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>
    <span class="n">probabilities</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">g_max_value</span> <span class="o">*</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">probabilities</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">resize</span><span class="p">(</span><span class="n">g_max_value</span> <span class="o">*</span> <span class="n">number</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">flag</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">g_max_value</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">probabilities</span><span class="p">[</span><span class="n">flag</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">k</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">k</span> <span class="o">&lt;=</span> <span class="n">number</span><span class="p">;</span> <span class="o">++</span><span class="n">k</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">probabilities</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">flag</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">k</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">g_max_value</span> <span class="o">*</span> <span class="n">k</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">probabilities</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">flag</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">i</span> <span class="o">&amp;&amp;</span> <span class="n">j</span> <span class="o">&lt;=</span> <span class="n">g_max_value</span><span class="p">;</span> <span class="o">++</span><span class="n">j</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">probabilities</span><span class="p">[</span><span class="mi">1</span> <span class="o">-</span> <span class="n">flag</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">probabilities</span><span class="p">[</span><span class="n">flag</span><span class="p">][</span><span class="n">i</span> <span class="o">-</span> <span class="n">j</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">flag</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">flag</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">double</span> <span class="n">total</span> <span class="o">=</span> <span class="n">pow</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">g_max_value</span><span class="p">,</span> <span class="n">number</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">number</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">g_max_value</span> <span class="o">*</span> <span class="n">number</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">ratio</span> <span class="o">=</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">probabilities</span><span class="p">[</span><span class="n">flag</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">total</span><span class="p">;</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d: %e</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">ratio</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div>


<h4 id="44">面试题44：扑克牌的顺子</h4>
<blockquote>
<p>从扑克牌中随机抽 5 张牌，判断是不是一个顺子，即这 5 张牌是不是连续的。大、小王可以看成任意数字。</p>
</blockquote>
<p>不妨把大、小王都定义为 0 ，以与 1 至 13 区分开。</p>
<ol>
<li>将数组排序（如果出现重复的非 0 数，一定不是顺子）</li>
<li>统计数组中 0 的个数</li>
<li>统计排序后数组中相邻数字之间的空缺总数，如果空缺的总数小于等于 0 的个数，则是顺子</li>
</ol>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">bool</span> <span class="n">IsContinuous</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
            <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

        <span class="n">sort</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

        <span class="kt">int</span> <span class="n">num_zeros</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">num_gaps</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">for_each</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">num_zeros</span><span class="p">](</span><span class="k">const</span> <span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
                <span class="o">++</span><span class="n">num_zeros</span><span class="p">;</span>
        <span class="p">});</span>

        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
        <span class="kt">int</span> <span class="n">small</span> <span class="o">=</span> <span class="n">num_zeros</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">big</span> <span class="o">=</span> <span class="n">small</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">big</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">==</span> <span class="n">numbers</span><span class="p">[</span><span class="n">big</span><span class="p">])</span>
                <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

            <span class="n">num_gaps</span> <span class="o">+=</span> <span class="p">(</span><span class="n">numbers</span><span class="p">[</span><span class="n">big</span><span class="p">]</span> <span class="o">-</span> <span class="n">numbers</span><span class="p">[</span><span class="n">small</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
            <span class="o">++</span><span class="n">small</span><span class="p">,</span> <span class="o">++</span><span class="n">big</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">num_zeros</span> <span class="o">&gt;=</span> <span class="n">num_gaps</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h4 id="45">面试题45：圆圈中最后剩下的数字（约瑟夫环）</h4>
<blockquote>
<p>0, 1, 2, ..., n-1 这 n 个数字排成一个圆圈，从数字 0 开始数，删除数到的第 m 个数字，然后从被删的数字的下一个数开始数，删除数到的第 m 个数字。。。求这个圆圈中剩下的最后一个数。</p>
</blockquote>
<p>解法1：环形链表模拟</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">LastRemaining_Solution</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="n">list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">numbers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>

        <span class="k">auto</span> <span class="n">cur</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="o">++</span><span class="n">cur</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">cur</span> <span class="o">==</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
                    <span class="n">cur</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="k">auto</span> <span class="n">next</span> <span class="o">=</span> <span class="o">++</span><span class="n">cur</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">next</span> <span class="o">==</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
                <span class="n">next</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

            <span class="o">--</span><span class="n">cur</span><span class="p">;</span>
            <span class="n">numbers</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">cur</span><span class="p">);</span>
            <span class="n">cur</span> <span class="o">=</span> <span class="n">next</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="o">*</span><span class="n">cur</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<p>时间复杂度为 O(m * n)，空间复杂度 O(n)</p>
<p>解法2：数学性质</p>
<div class="hlcode"><pre><span class="err">记</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="err">为</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">...,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="err">这</span> <span class="n">n</span> <span class="err">个数，每次删除第</span> <span class="n">m</span> <span class="err">个数（然后从被删的数的下一个位置开始计数），这样删到最后剩下的那一个数。</span>

<span class="err">第一个被删除的数字为</span> <span class="p">(</span><span class="n">m</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="err">。此时圆圈中的数从</span> <span class="n">n</span> <span class="err">个变成了</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="err">个。为了简单起见，令</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="err">，则剩下的</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="err">个数为</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="p">...,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="err">。下一次删除从数字</span> <span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="err">开始计数，相当于在剩下的序列中，</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="err">排在最前面，形成</span> <span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="err">。这个序列最后剩下的数字也是关于</span> <span class="n">n</span> <span class="err">和</span> <span class="n">m</span> <span class="err">函数，但由于此时该序列已经不符合</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="err">的定义（从</span> <span class="mi">0</span> <span class="err">开始的连续序列），因此该函数不同于前面定义的函数，记为</span> <span class="n">f</span><span class="err">&#39;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span><span class="err">。最初序列最后剩下的数字</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="err">一定是删除一个数字之后的序列最后剩下的数字，即</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="n">f</span><span class="err">&#39;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

<span class="err">我们把剩下的</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span> <span class="err">个数字</span> <span class="p">[</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="p">...,</span> <span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="err">做一个映射：</span>
<span class="n">k</span><span class="o">+</span><span class="mi">1</span> <span class="o">-------------------------&gt;</span> <span class="mi">0</span>
<span class="n">k</span><span class="o">+</span><span class="mi">2</span> <span class="o">-------------------------&gt;</span> <span class="mi">1</span>
<span class="p">...</span>
<span class="n">n</span><span class="o">-</span><span class="mi">1</span>  <span class="o">-------------------------&gt;</span> <span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">2</span>
<span class="mi">0</span>      <span class="o">-------------------------&gt;</span> <span class="n">n</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span>
<span class="mi">1</span>      <span class="o">-------------------------&gt;</span> <span class="n">n</span><span class="o">-</span><span class="n">k</span>
<span class="p">...</span>
<span class="n">k</span><span class="o">-</span><span class="mi">1</span>   <span class="o">-------------------------&gt;</span> <span class="n">n</span><span class="o">-</span><span class="mi">2</span>

<span class="err">我们把该映射定义为</span> <span class="n">p</span><span class="p">()</span><span class="err">，则</span> <span class="n">p</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">-</span><span class="n">k</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="err">，其逆映射为</span> <span class="n">p</span><span class="o">^</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">}(</span><span class="n">x</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">+</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span><span class="err">。</span>

<span class="err">映射后的序列仍然满足从</span> <span class="mi">0</span> <span class="err">开始的连续序列，可以用</span> <span class="n">f</span> <span class="err">来表示，记为</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span><span class="err">。</span>

<span class="n">f</span><span class="err">&#39;</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="n">p</span><span class="o">^</span><span class="p">{</span><span class="o">-</span><span class="mi">1</span><span class="p">}</span> <span class="p">[</span> <span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">%</span> <span class="n">n</span><span class="err">，把</span> <span class="n">k</span> <span class="o">=</span> <span class="p">(</span><span class="n">m</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="n">n</span> <span class="err">代入，得到：</span>

<span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">f</span><span class="p">(</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="n">m</span><span class="p">]</span> <span class="o">%</span> <span class="n">n</span><span class="p">,</span> <span class="n">n</span> <span class="o">&gt;=</span> <span class="mi">1</span>

<span class="err">当</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">1</span> <span class="err">时，只有一个数</span> <span class="mi">0</span><span class="err">，则</span> <span class="n">f</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>


<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">LastRemaining_Solution</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span> <span class="o">||</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

        <span class="kt">int</span> <span class="n">last</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
            <span class="n">last</span> <span class="o">=</span> <span class="p">(</span><span class="n">last</span> <span class="o">+</span> <span class="n">m</span><span class="p">)</span> <span class="o">%</span> <span class="n">i</span><span class="p">;</span>

        <span class="k">return</span> <span class="n">last</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h3 id="_2">发散思维能力</h3>
<ul>
<li>探索多种解法。</li>
<li>是否有探索新思路的激情。</li>
</ul>
<h4 id="46-12n">面试题46：求 1+2+...+n</h4>
<blockquote>
<p>要求不能使用乘除法、for、while、if、else、switch、case 等关键字以及三目条件运算语句。</p>
</blockquote>
<p>解法1：利用构造函数求解</p>
<p>不能用循环，循环只是让相同的代码重复执行 n 遍而已，我们可以先定义一个类型，接着创建 n 个该类型的实例，那么这个类型的构造函数将被调用 n 次。</p>
<p>解法2：利用虚函数</p>
<p>不能使用 if ，所以不能直接用递归（递归终止条件）。不妨定义两个函数，一个函数充当递归函数的角色，另一个函数处理终止递归的情况。现在还需要的就是在两个函数里二选一，自然要用到 bool 变量，比如 true 时调用第一个函数，false 调用第二个函数。如何把数值 n 转换为 bool 变量。两次取反，非0 的 n 两次取反后为 true，0 两次取反后为 false。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">A</span><span class="p">;</span>
<span class="n">A</span><span class="o">*</span> <span class="n">func</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

<span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">sum</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">[</span><span class="o">!!</span><span class="n">n</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sum_from_one_to_n</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">A</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">func</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">;</span>
    <span class="n">func</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">b</span><span class="p">.</span><span class="n">sum</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>解法3：利用函数指针</p>
<p>本质上还是用两个函数，一个作为递归边界。</p>
<div class="hlcode"><pre><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="nf">int</span><span class="p">(</span><span class="o">*</span><span class="n">fun</span><span class="p">)(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">terminator</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">sum_from_one_to_n</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">static</span> <span class="n">fun</span> <span class="n">f</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="n">terminator</span><span class="p">,</span> <span class="n">sum_from_one_to_n</span> <span class="p">};</span>
    <span class="k">return</span> <span class="n">n</span> <span class="o">+</span> <span class="n">f</span><span class="p">[</span><span class="o">!!</span><span class="n">n</span><span class="p">](</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>


<p>解法4：利用模板</p>
<div class="hlcode"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">n</span><span class="o">&gt;</span>
<span class="k">struct</span> <span class="kt">sum_solution_t</span>
<span class="p">{</span>
    <span class="k">enum</span>
    <span class="p">{</span>
        <span class="n">N</span> <span class="o">=</span> <span class="kt">sum_solution_t</span><span class="o">&lt;</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="o">&gt;::</span><span class="n">N</span> <span class="o">+</span> <span class="n">n</span>
    <span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;&gt;</span>
<span class="k">struct</span> <span class="kt">sum_solution_t</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="k">enum</span>
    <span class="p">{</span>
        <span class="n">N</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">};</span>
<span class="p">};</span>
</pre></div>


<p>sum_solution_t&lt;100&gt;::N 就是 1 到 100 的累加和。</p>
<p>这里利用了模板类型特化作为递归边界。</p>
<h4 id="47">面试题47：不用加减乘除做加法</h4>
<blockquote>
<p>写一个函数，求两个整数之和，要求在函数体内不得使用 + - * / 运算符。</p>
</blockquote>
<p>如何分析这个问题？不能用四则运算，剩下的只有位运算了。怎么找规律？</p>
<div class="hlcode"><pre><span class="err">先考虑我们是如何进行</span> <span class="mi">10</span> <span class="err">进制加法的。</span>
<span class="err">以</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">17</span> <span class="o">=</span> <span class="mi">22</span> <span class="err">为例子。可以分三步进行：</span>
<span class="mf">1.</span> <span class="err">只做各个位上的数字相加，不考虑进位</span> <span class="o">-&gt;</span> <span class="mi">5</span><span class="o">+</span><span class="mi">7</span> <span class="err">取个位为</span> <span class="mi">2</span><span class="err">，得</span> <span class="mi">12</span>
<span class="mf">2.</span> <span class="err">做进位，</span><span class="mi">5</span><span class="o">+</span><span class="mi">7</span><span class="err">的进位为</span> <span class="mi">10</span>
<span class="mf">3.</span> <span class="err">将前面的两个结果加起来，得</span> <span class="mi">5</span> <span class="o">+</span> <span class="mi">17</span> <span class="o">=</span> <span class="mi">22</span>

<span class="err">现在从二进制来考虑。</span>
<span class="mi">5</span> <span class="err">的二进制为</span> <span class="mo">00101</span>
<span class="mi">17</span> <span class="err">的二进制为</span> <span class="mi">10001</span>

<span class="mf">1.</span> <span class="err">不考虑进位，</span><span class="mi">10100</span> 
<span class="mf">2.</span> <span class="err">只看进位，</span><span class="mo">00010</span>
<span class="mf">3.</span> <span class="err">将两个结果相加，</span><span class="mi">10110</span>

<span class="err">注意第一步不考虑进位做各个二进制位的相加，相当于异或运算。</span>
<span class="err">第二步只看进位，可以用“与操作</span><span class="o">+</span><span class="err">左移一位”实现。</span>
<span class="err">第三步再将两个结果相加，注意不能直接相加，于是重复前面两步，这就形成了递归，直到不产生进位为止（此时异或结果就是最终结果）。</span>

<span class="err">例子：</span>

<span class="o">====================================</span>
<span class="mi">7</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">=</span> <span class="mi">9</span>

<span class="mi">7</span> <span class="o">:</span> <span class="mo">0111</span>
<span class="mi">2</span> <span class="o">:</span> <span class="mo">0010</span>
<span class="mi">9</span> <span class="o">:</span> <span class="mi">1001</span>

<span class="err">不考虑进位的二进制“加”：</span>

<span class="mo">0111</span>
<span class="mo">0010</span>
<span class="o">------</span>
<span class="mo">0101</span>

<span class="err">相当于“异或”。</span>

<span class="err">怎么处理进位？</span>

<span class="err">当两个数对应位上都为</span> <span class="mi">1</span> <span class="err">时会发生进位。</span>

<span class="err">使用“与”操作：</span>

<span class="mo">0111</span>
<span class="mo">0010</span>
<span class="o">------</span>
<span class="mo">0010</span>

<span class="mo">0010</span> <span class="err">左移一位</span> <span class="mo">0100</span><span class="err">，和</span> <span class="mo">0101</span> <span class="err">异或得到</span> <span class="mo">0001</span><span class="err">（不考虑进位的“加法”），和</span><span class="mo">0101</span><span class="err">与得到</span> <span class="mo">0100</span><span class="err">；</span>

<span class="mo">0100</span> <span class="err">左移一位</span> <span class="mi">1000</span><span class="err">，和</span> <span class="mo">0001</span> <span class="err">异或得到</span> <span class="mi">1001</span><span class="err">，和</span> <span class="mo">0001</span> <span class="err">与得到</span> <span class="mo">0000</span><span class="err">（终止）。</span>
<span class="o">====================================</span>
</pre></div>


<div class="hlcode"><pre><span class="k">class</span> <span class="nc">Solution</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">num1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">carry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">do</span> 
        <span class="p">{</span>
            <span class="n">sum</span> <span class="o">=</span> <span class="n">num1</span> <span class="o">^</span> <span class="n">num2</span><span class="p">;</span>
            <span class="n">carry</span> <span class="o">=</span> <span class="p">(</span><span class="n">num1</span> <span class="o">&amp;</span> <span class="n">num2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>

            <span class="n">num1</span> <span class="o">=</span> <span class="n">sum</span><span class="p">;</span>
            <span class="n">num2</span> <span class="o">=</span> <span class="n">carry</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">while</span> <span class="p">(</span><span class="n">carry</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">);</span>

        <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></div>


<h4 id="48">面试题48：不能被继承的类</h4>
<blockquote>
<p>设计一个不能继承的 C++ 类</p>
</blockquote>
<p>标准解法：将构造函数设为私有函数</p>
<p>C++ 中子类的构造函数会自动调用父类的构造函数，子类的析构函数也会自动调用父类的析构函数。将一个类的构造函数和析构函数都定义为私有，当一个类试图从它那继承（并有 public 的构造函数）的时候，会导致编译错误。</p>
<p>问题是这个类的构造函数是私有的，如何创建实例？可以利用公有的静态类方法。</p>
<div class="hlcode"><pre><span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">static</span> <span class="n">A</span><span class="o">*</span> <span class="n">create_instance</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">A</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">delete_instance</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">delete</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">a</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>

<span class="nl">private:</span>
    <span class="n">A</span><span class="p">()</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">B</span><span class="p">()</span> <span class="p">{}</span>   <span class="c1">// 编译错误</span>
    <span class="o">~</span><span class="n">B</span><span class="p">()</span> <span class="p">{}</span>  <span class="c1">// 编译错误</span>
<span class="p">};</span>
</pre></div>


<p>更优雅的解法：利用虚拟继承</p>
<div class="hlcode"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> 
<span class="k">class</span> <span class="nc">MakeSealed</span>
<span class="p">{</span>
    <span class="k">friend</span> <span class="n">T</span><span class="p">;</span>

<span class="nl">private:</span>
    <span class="n">MakeSealed</span><span class="p">()</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">MakeSealed</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">A</span> <span class="o">:</span> <span class="k">virtual</span> <span class="k">public</span> <span class="n">MakeSealed</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">A</span><span class="p">()</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="c1">// 由于 A 是由 MakeSealed&lt;A&gt; 虚拟继承来的，在调用 B 的构造函数</span>
<span class="c1">// B() 时会跳过 A 的构造函数 A()，直接调用 MakeSealed&lt;A&gt; 的构造函数</span>
<span class="c1">// 但是 B 不是 MakeSealed&lt;A&gt; 的友元，所以编译不通过。</span>
<span class="k">class</span> <span class="nc">B</span> <span class="o">:</span> <span class="k">public</span> <span class="n">A</span>
<span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">B</span><span class="p">()</span> <span class="p">{}</span>   <span class="c1">// B 不是 MakeSealed&lt;A&gt; 的友元类型</span>
    <span class="o">~</span><span class="n">B</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></div>


<p>注意如果 A 不用虚拟继承，那么 B 还是可以通过编译的。（关键是虚拟继承情况下构造函数的调用顺序发生了变化）</p>
  <div class="relation">
    <h2>Related</h2>
    <ul>
    
    <li><a href="/wiki/algorithm/jianzhi_offer_notes_6.html">剑指offer笔记(6)</a></li>
    
    <li><a href="/wiki/algorithm/leetcode_solutions.html">LeetCode Solutions</a></li>
    
    <li><a href="/wiki/algorithm/jianzhi_offer_notes_2.html">剑指offer笔记(2)</a></li>
    
    <li><a href="/wiki/algorithm/jianzhi_offer_notes_3.html">剑指offer笔记(3)</a></li>
    
    <li><a href="/wiki/algorithm/ctci_notes.html">< Cracking The Code Interview > notes</a></li>
    
    <li><a href="/wiki/algorithm/jianzhi_offer_notes_4.html">剑指offer笔记(4)</a></li>
    
    <li><a href="/wiki/algorithm/jianzhi_offer_notes_1.html">剑指offer笔记(1)</a></li>
    
    </ul>
  </div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 Yilin Gui.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-07-24 01:10:00</p>
      </span>
    </div>

    
    
  </body>
</html>