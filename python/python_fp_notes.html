<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Python 函数式编程 - Yilin's Wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          <!--$表示行内元素，$$表示块状元素 -->
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <!--Mermaid流程图-->
    <script src="https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#python">python</a>&nbsp;&#187;&nbsp;Python 函数式编程
    <span class="updated">Page Updated&nbsp;
      2019-11-09 01:01
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">Python 函数式编程</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">高阶函数</a><ul>
<li><a href="#mapreduce">map/reduce</a></li>
<li><a href="#filter">filter</a></li>
<li><a href="#sorted">sorted</a></li>
</ul>
</li>
<li><a href="#_2">函数作为返回值</a><ul>
<li><a href="#_3">闭包</a></li>
</ul>
</li>
<li><a href="#lambda">lambda</a></li>
<li><a href="#_4">装饰器</a></li>
<li><a href="#partial-function">Partial function</a></li>
</ul>
</div>
<p>Functional Programming, 函数式编程就是一种抽象程度很高的编程范式，纯粹的函数式编程语言编写的函数没有变量，因此，任意一个函数，只要输入是确定的，输出就是确定的，这种纯函数我们称之为没有副作用。而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出，因此，这种函数是有副作用的。</p>
<p>函数式编程的一个特点就是，允许把函数本身作为参数传入另一个函数，还允许返回一个函数。</p>
<p>Python对函数式编程提供部分支持。由于Python允许使用变量，因此，Python不是纯函数式编程语言。</p>
<p>参考自<a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017328525009056">廖雪峰Python教程</a>。</p>
<hr />
<h2 id="_1">高阶函数</h2>
<p>Higher-order function.</p>
<p>将函数作为参数的函数称为高阶函数。</p>
<div class="hlcode"><pre><span></span><span class="k">def</span> <span class="nf">f1</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span>

<span class="k">def</span> <span class="nf">f2</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="c1"># g 是一个 high-order function</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
    <span class="k">return</span> <span class="nb">sum</span><span class="p">([</span><span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">xs</span><span class="p">])</span>

<span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>

<span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">f1</span><span class="p">))</span>  <span class="c1"># 6</span>
<span class="k">print</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">f2</span><span class="p">))</span>  <span class="c1"># 14</span>
</pre></div>


<h3 id="mapreduce">map/reduce</h3>
<p><code>map()</code> 函数接收两个参数，一个是函数，一个是 <code>Iterable</code> ， <code>map</code> 将传入的函数依次作用到序列的每个元素，并把结果作为新的 <code>Iterator</code> 返回。</p>
<div class="hlcode"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">**</span><span class="mi">2</span>

<span class="n">xs</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="nb">map</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">xs</span><span class="p">)</span>  <span class="c1">## [1, 4, 9]</span>
</pre></div>


<p><code>reduce()</code> 把一个函数作用在一个序列 <code>[x1, x2, x3, ...]</code> 上，这个函数必须接收两个参数， <code>reduce</code> 把结果继续和序列的下一个元素做累积计算:</p>
<div class="hlcode"><pre><span></span><span class="nb">reduce</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="p">[</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">])</span> <span class="o">=</span> <span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">),</span> <span class="n">x3</span><span class="p">),</span> <span class="n">x4</span><span class="p">)</span>
</pre></div>


<div class="hlcode"><pre><span></span><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>

<span class="nb">reduce</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>  <span class="c1">## 6</span>
</pre></div>


<p>这些高阶函数配合 lambda 使用可以写出非常简洁的代码。</p>
<h3 id="filter">filter</h3>
<p>Python内建的 <code>filter()</code> 函数用于过滤序列。</p>
<p><code>filter()</code> 把传入的函数依次作用于每个元素，然后根据返回值是 <code>True</code> 还是 <code>False</code> 决定保留还是丢弃该元素。</p>
<div class="hlcode"><pre><span></span><span class="c1"># 过滤偶数</span>
<span class="k">def</span> <span class="nf">is_odd</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span>

<span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">is_odd</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]))</span>  <span class="c1"># 1 3 5</span>

<span class="c1"># 删掉一个序列中的空字符串</span>
<span class="k">def</span> <span class="nf">not_empty</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">s</span> <span class="ow">and</span> <span class="n">s</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

<span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="n">not_empty</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="s1">&#39;  &#39;</span><span class="p">]))</span>
<span class="c1"># 结果: [&#39;A&#39;, &#39;B&#39;, &#39;C&#39;]</span>
</pre></div>


<p>注意到 <code>filter()</code> 函数返回的是一个 <code>Iterator</code> ，也就是一个惰性序列，所以要强迫 <code>filter()</code> 完成计算结果，需要用 <code>list()</code> 函数获得所有结果并返回 <code>list</code> 。</p>
<h3 id="sorted">sorted</h3>
<p>Python内置的 <code>sorted()</code> 函数可以对 <code>list</code> 进行排序。</p>
<div class="hlcode"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">([</span><span class="mi">36</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">21</span><span class="p">])</span>
<span class="p">[</span><span class="o">-</span><span class="mi">21</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">36</span><span class="p">]</span>
</pre></div>


<p><code>sorted()</code> 是一个高阶函数，它还可以接收一个 <code>key</code> 函数来实现自定义的排序，例如按绝对值大小排序：</p>
<div class="hlcode"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">([</span><span class="mi">36</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">21</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">abs</span><span class="p">)</span>
<span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="p">,</span><span class="o">-</span><span class="mi">21</span><span class="p">,</span> <span class="mi">36</span><span class="p">]</span>
</pre></div>


<p><code>sorted()</code> 还有一个参数是 <code>reverse</code>，为 <code>True</code> 时表示反向排序：</p>
<div class="hlcode"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">([</span><span class="mi">36</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="o">-</span><span class="mi">21</span><span class="p">],</span> <span class="n">key</span><span class="o">=</span><span class="nb">abs</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
<span class="p">[</span><span class="mi">36</span><span class="p">,</span> <span class="o">-</span><span class="mi">21</span><span class="p">,</span> <span class="o">-</span><span class="mi">12</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">5</span><span class="p">]</span>
</pre></div>


<h2 id="_2">函数作为返回值</h2>
<p>高阶函数除了可以接受函数作为参数外，还可以把函数作为结果值返回。</p>
<div class="hlcode"><pre><span></span><span class="k">def</span> <span class="nf">lazy_sum</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">sum</span><span class="p">():</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span> <span class="o">+</span> <span class="n">n</span>
        <span class="k">return</span> <span class="n">ax</span>
    <span class="k">return</span> <span class="nb">sum</span>  <span class="c1"># 返回一个函数</span>

<span class="c1"># 当我们调用lazy_sum()时，返回的并不是求和结果，而是求和函数：</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span> <span class="o">=</span> <span class="n">lazy_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f</span>
<span class="o">&lt;</span><span class="n">function</span> <span class="n">lazy_sum</span><span class="o">.&lt;</span><span class="nb">locals</span><span class="o">&gt;.</span><span class="n">sum</span> <span class="n">at</span> <span class="mh">0x101c6ed90</span><span class="o">&gt;</span>

<span class="c1"># 调用lazy_sum()时，每次调用都会返回一个新的函数</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f1</span> <span class="o">=</span> <span class="n">lazy_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f2</span> <span class="o">=</span> <span class="n">lazy_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">9</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">f1</span><span class="o">==</span><span class="n">f2</span>
<span class="bp">False</span>
</pre></div>


<p>这里 sum 是一个闭包（Closure），它可以访问到 lazy_sum 中定义的变量。</p>
<h3 id="_3">闭包</h3>
<blockquote>
<p>在计算机科学中，闭包（Closure）是词法闭包（Lexical Closure）的简称，是引用了自由变量的函数。这个被引用的自由变量将和这个函数一同存在，即使已经离开了创造它的环境也不例外。所以，有另一种说法认为闭包是由函数和与其相关的引用环境组合而成的实体。</p>
</blockquote>
<div class="hlcode"><pre><span></span><span class="k">def</span> <span class="nf">count</span><span class="p">():</span>
    <span class="n">n</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
        <span class="c1"># 注意 nonlocal 关键字，表示 n 是外部作用域定义的</span>
        <span class="n">nonlocal</span> <span class="n">n</span>
        <span class="n">n</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">n</span>
    <span class="k">return</span> <span class="n">f</span>

<span class="n">f1</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>
<span class="n">f2</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>
<span class="n">f3</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>
<span class="c1"># f1 f2 f3 互相之间不会干扰</span>
<span class="k">print</span><span class="p">(</span><span class="n">f1</span><span class="p">(),</span> <span class="n">f2</span><span class="p">(),</span> <span class="n">f3</span><span class="p">())</span>  <span class="c1"># 1 1 1</span>
<span class="k">print</span><span class="p">(</span><span class="n">f1</span><span class="p">(),</span> <span class="n">f2</span><span class="p">(),</span> <span class="n">f3</span><span class="p">())</span>  <span class="c1"># 2 2 2</span>
<span class="k">print</span><span class="p">(</span><span class="n">f1</span><span class="p">(),</span> <span class="n">f2</span><span class="p">(),</span> <span class="n">f3</span><span class="p">())</span>  <span class="c1"># 3 3 3</span>
</pre></div>


<p>使用闭包要注意，返回函数不要引用任何循环变量，或者后续会发生变化的变量：</p>
<div class="hlcode"><pre><span></span><span class="c1"># 错误的写法</span>
<span class="k">def</span> <span class="nf">count</span><span class="p">():</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">f</span><span class="p">():</span>
             <span class="k">return</span> <span class="n">i</span><span class="o">*</span><span class="n">i</span>
        <span class="n">fs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">fs</span>

<span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>
<span class="n">f1</span><span class="p">(),</span> <span class="n">f2</span><span class="p">(),</span> <span class="n">f3</span><span class="p">()</span>  <span class="c1"># 9 9 9</span>
<span class="c1"># 因为 `return fs` 时，变量 i 的值为 3。</span>

<span class="c1"># 正确的写法</span>
<span class="c1"># 再创建一个函数，用该函数的参数绑定循环变量当前的值</span>
<span class="c1"># 无论该循环变量后续如何更改，已绑定到函数参数的值不变</span>
<span class="k">def</span> <span class="nf">count</span><span class="p">():</span>
    <span class="n">fs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">j</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">g</span><span class="p">():</span>
            <span class="k">return</span> <span class="n">j</span> <span class="o">*</span> <span class="n">j</span>
        <span class="k">return</span> <span class="n">g</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">):</span>
        <span class="n">fs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">i</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">fs</span>

<span class="n">f1</span><span class="p">,</span> <span class="n">f2</span><span class="p">,</span> <span class="n">f3</span> <span class="o">=</span> <span class="n">count</span><span class="p">()</span>
<span class="k">print</span><span class="p">(</span><span class="n">f1</span><span class="p">(),</span> <span class="n">f2</span><span class="p">(),</span> <span class="n">f3</span><span class="p">())</span>
<span class="c1"># 1 4 9</span>
</pre></div>


<h2 id="lambda">lambda</h2>
<p>Python 中对 lambda 表达式提供了有限的支持，lambda 表达式可以看成一个匿名函数：</p>
<div class="hlcode"><pre><span></span><span class="o">&gt;&gt;&gt;</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span> <span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">]))</span>
<span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">25</span><span class="p">,</span> <span class="mi">36</span><span class="p">,</span> <span class="mi">49</span><span class="p">,</span> <span class="mi">64</span><span class="p">,</span> <span class="mi">81</span><span class="p">]</span>
</pre></div>


<p>Python 因为本身设计思想，仅仅将 lambda 定位成一个辅助用的短函数，比如不能换行，不能用来实现闭包（无法访问外部作用域变量）。</p>
<h2 id="_4">装饰器</h2>
<p>在代码运行期间动态增加功能的方式，称之为“装饰器”（Decorator）。</p>
<p>本质上，decorator就是 <strong>一个返回函数的高阶函数</strong> 。</p>
<p>例子：</p>
<div class="hlcode"><pre><span></span><span class="k">def</span> <span class="nf">now</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;2019-09-09&#39;</span><span class="p">)</span>

<span class="c1"># 我们希望调用 now() 时能自动打一行 log</span>
<span class="c1"># 定义一个 log 装饰器</span>
<span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="c1"># 把传入的函数“包装/装饰”了一下</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;call </span><span class="si">%s</span><span class="s1">():&#39;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>

<span class="c1"># Python的@语法，把decorator置于函数的定义处</span>
<span class="nd">@log</span>
<span class="k">def</span> <span class="nf">now</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;2019-09-09&#39;</span><span class="p">)</span>

<span class="n">now</span><span class="p">()</span>  <span class="c1"># 实际上执行的是 log(now)()</span>
<span class="c1"># call now():</span>
<span class="c1"># 2019-09-09</span>
</pre></div>


<p>如果装饰器函数本身也有参数，那就需要编写一个返回decorator的高阶函数：</p>
<div class="hlcode"><pre><span></span><span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">text</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">decorator</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
            <span class="k">print</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1"> </span><span class="si">%s</span><span class="s1">():&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">wrapper</span>
    <span class="k">return</span> <span class="n">decorator</span>

<span class="nd">@log</span><span class="p">(</span><span class="s1">&#39;call&#39;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">now</span><span class="p">():</span>
    <span class="k">print</span><span class="p">(</span><span class="s1">&#39;2019-09-09&#39;</span><span class="p">)</span>

<span class="n">now</span><span class="p">()</span>  <span class="c1"># 相当于 log(&#39;call&#39;)(now)()</span>

<span class="c1"># 注意此时 now 的函数名已经变成了 &#39;wrapper&#39;</span>
<span class="k">print</span><span class="p">(</span><span class="n">now</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
</pre></div>


<p>定义装饰器时，一般需要把原始函数的__name__等属性复制到wrapper()函数中，否则，有些依赖函数签名的代码执行就会出错。Python内置的 <code>functools.wraps</code> 可以帮我们完成这个任务。</p>
<div class="hlcode"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>

<span class="k">def</span> <span class="nf">log</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
    <span class="nd">@functools.wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="s1">&#39;call </span><span class="si">%s</span><span class="s1">():&#39;</span> <span class="o">%</span> <span class="n">func</span><span class="o">.</span><span class="vm">__name__</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kw</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">wrapper</span>
</pre></div>


<h2 id="partial-function">Partial function</h2>
<p><code>functools.partial</code> 帮助我们绑定函数的一些参数，返回一个新的函数：</p>
<div class="hlcode"><pre><span></span><span class="kn">import</span> <span class="nn">functools</span>
<span class="n">int2</span> <span class="o">=</span> <span class="n">functools</span><span class="o">.</span><span class="n">partial</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">int2</span><span class="p">(</span><span class="s1">&#39;0010&#39;</span><span class="p">)</span>  <span class="c1"># 2</span>
<span class="n">int2</span><span class="p">(</span><span class="s1">&#39;0100&#39;</span><span class="p">)</span>  <span class="c1"># 4</span>
</pre></div>
  <div class="relation">
    <h2>Related</h2>
    <ul>
    
    <li><a href="/wiki/tools/anaconda_python_notes.html">Anaconda notes</a></li>
    
    <li><a href="/wiki/python/python_oop.html">Python 面向对象编程</a></li>
    
    <li><a href="/wiki/python/python_database.html">Python 数据库访问</a></li>
    
    <li><a href="/wiki/python/python_network_programming.html">Python 网络编程</a></li>
    
    <li><a href="/wiki/python/python_basics_notes.html">Python Basics Notes</a></li>
    
    <li><a href="/wiki/python/python_email.html">Python 收发电子邮件</a></li>
    
    <li><a href="/wiki/python/python_modules.html">Python 中的模块</a></li>
    
    <li><a href="/wiki/python/python_debugging_and_tests.html">Python 错误处理与测试</a></li>
    
    <li><a href="/wiki/python/python_process_thread_and_async_io.html">Python 进程、线程与异步IO</a></li>
    
    <li><a href="/wiki/python/python_IO.html">Python IO 编程</a></li>
    
    </ul>
  </div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 Yilin Gui.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-11-20 01:35:15</p>
      </span>
    </div>

    
    
  </body>
</html>