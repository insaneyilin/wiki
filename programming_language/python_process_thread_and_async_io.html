<!DOCTYPE HTML>
<html>
  <head>
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/style.css">
    <link rel="Stylesheet" type="text/css" href="/wiki/static/css/tango.css">
    <link rel="shortcut icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="icon" href="/wiki/favicon.ico" type="image/x-icon">
    <link rel="alternate" type="application/atom+xml" href="atom.xml" title="Atom feed">
    <title>Python 进程、线程与异步IO - Yilin's Wiki</title>
    <meta name="keywords" content=""/>
    <meta name="description" content=""/>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          <!--$表示行内元素，$$表示块状元素 -->
          inlineMath: [ ['$','$'], ["\\(","\\)"] ],
          displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre']
        },
        "HTML-CSS": { availableFonts: ["TeX"] }
      });
    </script>
    <script type="text/javascript" async
      src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML">
    </script>

    <!--Mermaid流程图-->
    <script src="https://cdn.bootcss.com/mermaid/8.0.0-rc.8/mermaid.min.js"></script>
    <script>mermaid.initialize({startOnLoad:true});</script>
  </head>

  <body>
    <div id="container">
      
<div id="header">
  <div class="post-nav"><a href="/wiki/">Home</a>&nbsp;&#187;&nbsp;<a href="/wiki/#programming_language">programming_language</a>&nbsp;&#187;&nbsp;Python 进程、线程与异步IO
    <span class="updated">Page Updated&nbsp;
      2019-11-13 23:22
    </span></div>
</div>
<div class="clearfix"></div>

<div class="page_title">Python 进程、线程与异步IO</div>

  <div class="toc"><span class="toctitle">Table of Contents</span><ul>
<li><a href="#_1">多进程</a></li>
<li><a href="#multiprocessing">multiprocessing</a></li>
<li><a href="#multiprocessingpool">multiprocessing.Pool</a></li>
<li><a href="#_2">子进程</a></li>
<li><a href="#_3">进程间通信</a></li>
</ul>
</div>
<p>现代操作系统基本上都是支持“多任务”的。</p>
<p>现在，多核CPU已经非常普及了，但是，即使过去的单核CPU，也可以执行多任务。由于CPU执行代码都是顺序执行的，那么，单核CPU是怎么执行多任务的呢？</p>
<p>答案就是 <strong>操作系统轮流让各个任务交替执行</strong> ，任务1执行0.01秒，切换到任务2，任务2执行0.01秒，再切换到任务3，执行0.01秒……这样反复执行下去。表面上看，每个任务都是交替执行的，但是， <strong>由于CPU的执行速度实在是太快了，我们感觉就像所有任务都在同时执行一样</strong> 。</p>
<p>真正的并行执行多任务只能在多核CPU上实现，但是，由于任务数量远远多于CPU的核心数量，所以，操作系统也会 <strong>自动把很多任务轮流调度到每个核心上执行</strong> 。</p>
<p>对于操作系统来说，一个任务就是一个进程（Process），比如打开一个浏览器就是启动一个浏览器进程，打开一个记事本就启动了一个记事本进程，打开两个记事本就启动了两个记事本进程，打开一个Word就启动了一个Word进程。</p>
<p>有些进程还不止同时干一件事，比如Word，它可以同时进行打字、拼写检查、打印等事情。在一个进程内部，要同时干多件事，就需要同时运行多个“子任务”，我们 <strong>把进程内的这些“子任务”称为线程（Thread）</strong> 。</p>
<p>由于每个进程至少要干一件事，所以， <strong>一个进程至少有一个线程</strong> 。</p>
<p>多任务的实现有3种方式：</p>
<ul>
<li>多进程模式；</li>
<li>多线程模式；</li>
<li>多进程 + 多线程模式。</li>
</ul>
<p>多进程和多线程的程序涉及到同步、数据共享的问题，编写起来更复杂。</p>
<p>参考 <a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1017627212385376">廖雪峰Python教程</a> 。</p>
<hr />
<h2 id="_1">多进程</h2>
<p>先了解操作系统关于进程的相关知识。</p>
<p>Unix/Linux操作系统提供了一个 <code>fork()</code> 系统调用，它非常特殊。普通的函数调用，调用一次，返回一次，但是 <code>fork()</code> <strong>调用一次，返回两次</strong> ，因为操作系统自动把当前进程（称为父进程）复制了一份（称为子进程），然后， <strong>分别在父进程和子进程内返回</strong> 。</p>
<p>子进程永远返回 <code>0</code> ，而父进程返回子进程的ID。这样做的理由是，一个父进程可以 <code>fork</code> 出很多子进程，所以，父进程要 <strong>记下每个子进程的ID</strong> ，而子进程只需要调用 <code>getppid()</code> 就可以拿到父进程的ID。</p>
<p>Python的 <code>os</code> 模块封装了常见的系统调用，其中就包括 <code>fork</code> ，可以在Python程序中轻松创建子进程：</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">os</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;Process (</span><span class="si">%s</span><span class="s">) start...&#39;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
<span class="c"># Only works on Unix/Linux/Mac:</span>
<span class="n">pid</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">fork</span><span class="p">()</span>
<span class="k">if</span> <span class="n">pid</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;I am child process (</span><span class="si">%s</span><span class="s">) and my parent is </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">os</span><span class="o">.</span><span class="n">getppid</span><span class="p">()))</span>
<span class="k">else</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;I (</span><span class="si">%s</span><span class="s">) just created a child process (</span><span class="si">%s</span><span class="s">).&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">(),</span> <span class="n">pid</span><span class="p">))</span>
</pre></div>


<p>由于Windows没有fork调用，上面的代码在Windows上无法运行。</p>
<p>关于 Windows 下创建进程，WINAPI 中有 <code>CreateProcess</code>。至于具体内容，那就是另外一回事了。</p>
<p>有了fork调用，一个进程在接到新任务时就可以复制出一个子进程来处理新任务，常见的Apache服务器就是由父进程监听端口，每当有新的http请求时，就fork出子进程来处理新的http请求。</p>
<h2 id="multiprocessing">multiprocessing</h2>
<p>Python 的 <code>multiprocessing</code> 模块是跨平台版本的多进程模块。</p>
<p><code>multiprocessing</code> 模块提供了一个 <code>Process</code> 类来代表一个进程对象，下面的例子演示了启动一个子进程并等待其结束：</p>
<div class="hlcode"><pre><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span>
<span class="kn">import</span> <span class="nn">os</span>

<span class="c"># 子进程要执行的代码</span>
<span class="k">def</span> <span class="nf">run_proc</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Run child process </span><span class="si">%s</span><span class="s"> (</span><span class="si">%s</span><span class="s">)...&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()))</span>

<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Parent process </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">run_proc</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="s">&#39;test&#39;</span><span class="p">,))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Child process will start.&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Child process end.&#39;</span><span class="p">)</span>
</pre></div>


<p>创建子进程时，只需要传入一个执行函数和函数的参数，创建一个 <code>Process</code> 实例，用 <code>start()</code> 方法启动，这样创建进程比 <code>fork()</code> 还要简单。</p>
<p><code>join()</code> 方法可以 <strong>等待子进程结束后再继续往下运行</strong> ，通常用于 <strong>进程间的同步</strong> 。</p>
<h2 id="multiprocessingpool">multiprocessing.Pool</h2>
<p>如果要启动大量的子进程，可以用进程池的方式批量创建子进程：</p>
<div class="hlcode"><pre><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Pool</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>

<span class="k">def</span> <span class="nf">long_time_task</span><span class="p">(</span><span class="n">name</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Run task </span><span class="si">%s</span><span class="s"> (</span><span class="si">%s</span><span class="s">)...&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">()))</span>
    <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Task </span><span class="si">%s</span><span class="s"> runs </span><span class="si">%0.2f</span><span class="s"> seconds.&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)))</span>

<span class="c"># 对Pool对象调用join()方法会等待所有子进程执行完毕</span>
<span class="c"># 调用join()之前必须先调用close()，调用close()之后就不能继续添加新的Process了。</span>
<span class="c"># 由于Pool的默认大小是CPU的核数，如果创建进程数量超过核数，需要等前面的进程执行完毕再创建新进程</span>
<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Parent process </span><span class="si">%s</span><span class="s">.&#39;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">Pool</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">5</span><span class="p">):</span>
        <span class="n">p</span><span class="o">.</span><span class="n">apply_async</span><span class="p">(</span><span class="n">long_time_task</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">i</span><span class="p">,))</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Waiting for all subprocesses done...&#39;</span><span class="p">)</span>
    <span class="n">p</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    <span class="n">p</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;All subprocesses done.&#39;</span><span class="p">)</span>
</pre></div>


<h2 id="_2">子进程</h2>
<p>很多时候，子进程并不是自身，而是一个外部进程。我们创建了子进程后，还需要控制子进程的输入和输出。</p>
<p><code>subprocess</code> 模块可以让我们非常方便地启动一个子进程，然后控制其输入和输出。</p>
<p>下面的例子演示了如何在Python代码中运行命令 <code>nslookup www.python.org</code> ，这和命令行直接运行的效果是一样的：</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">subprocess</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;$ nslookup www.python.org&#39;</span><span class="p">)</span>
<span class="c"># subprocess.call 直接调用命令行</span>
<span class="n">r</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">call</span><span class="p">([</span><span class="s">&#39;nslookup&#39;</span><span class="p">,</span> <span class="s">&#39;www.python.org&#39;</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Exit code:&#39;</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
</pre></div>


<p>如果子进程还需要输入，则可以通过 <code>communicate()</code> 方法输入：</p>
<div class="hlcode"><pre><span class="kn">import</span> <span class="nn">subprocess</span>

<span class="k">print</span><span class="p">(</span><span class="s">&#39;$ nslookup&#39;</span><span class="p">)</span>
<span class="c"># 先执行 nslookup</span>
<span class="n">p</span> <span class="o">=</span> <span class="n">subprocess</span><span class="o">.</span><span class="n">Popen</span><span class="p">([</span><span class="s">&#39;nslookup&#39;</span><span class="p">],</span> <span class="n">stdin</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stdout</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">,</span> <span class="n">stderr</span><span class="o">=</span><span class="n">subprocess</span><span class="o">.</span><span class="n">PIPE</span><span class="p">)</span>
<span class="c"># 然后再输入 nslookup 指令</span>
<span class="n">output</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">communicate</span><span class="p">(</span><span class="n">b</span><span class="s">&#39;set q=mx</span><span class="se">\n</span><span class="s">python.org</span><span class="se">\n</span><span class="s">exit</span><span class="se">\n</span><span class="s">&#39;</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">output</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s">&#39;utf-8&#39;</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="s">&#39;Exit code:&#39;</span><span class="p">,</span> <span class="n">p</span><span class="o">.</span><span class="n">returncode</span><span class="p">)</span>
</pre></div>


<h2 id="_3">进程间通信</h2>
<p><code>Process</code> 之间肯定是需要通信的，操作系统提供了很多机制来实现进程间的通信。Python的 <code>multiprocessing</code> 模块包装了底层的机制，提供了 <code>Queue</code> 、 <code>Pipes</code> 等多种方式来交换数据。</p>
<p>我们以 <code>Queue</code> 为例，在父进程中创建两个子进程，一个往 <code>Queue</code> 里写数据，一个从 <code>Queue</code> 里读数据：</p>
<p><code>multiprocessing.Queue</code> 是专门用于进程间通信的队列，和 Python 标准库中的 <code>Queue</code> 有区别。</p>
<div class="hlcode"><pre><span class="kn">from</span> <span class="nn">multiprocessing</span> <span class="kn">import</span> <span class="n">Process</span><span class="p">,</span> <span class="n">Queue</span>
<span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">time</span><span class="o">,</span> <span class="nn">random</span>

<span class="c"># 写数据进程执行的代码:</span>
<span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Process to write: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s">&#39;A&#39;</span><span class="p">,</span> <span class="s">&#39;B&#39;</span><span class="p">,</span> <span class="s">&#39;C&#39;</span><span class="p">]:</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Put </span><span class="si">%s</span><span class="s"> to queue...&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>
        <span class="n">q</span><span class="o">.</span><span class="n">put</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="n">time</span><span class="o">.</span><span class="n">sleep</span><span class="p">(</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">())</span>

<span class="c"># 读数据进程执行的代码:</span>
<span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">q</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="s">&#39;Process to read: </span><span class="si">%s</span><span class="s">&#39;</span> <span class="o">%</span> <span class="n">os</span><span class="o">.</span><span class="n">getpid</span><span class="p">())</span>
    <span class="k">while</span> <span class="bp">True</span><span class="p">:</span>
        <span class="n">value</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">True</span><span class="p">)</span>
        <span class="k">print</span><span class="p">(</span><span class="s">&#39;Get </span><span class="si">%s</span><span class="s"> from queue.&#39;</span> <span class="o">%</span> <span class="n">value</span><span class="p">)</span>

<span class="k">if</span> <span class="n">__name__</span><span class="o">==</span><span class="s">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="c"># 父进程创建Queue，并传给各个子进程：</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">Queue</span><span class="p">()</span>
    <span class="n">pw</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">write</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="n">pr</span> <span class="o">=</span> <span class="n">Process</span><span class="p">(</span><span class="n">target</span><span class="o">=</span><span class="n">read</span><span class="p">,</span> <span class="n">args</span><span class="o">=</span><span class="p">(</span><span class="n">q</span><span class="p">,))</span>
    <span class="c"># 启动子进程pw，写入:</span>
    <span class="n">pw</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="c"># 启动子进程pr，读取:</span>
    <span class="n">pr</span><span class="o">.</span><span class="n">start</span><span class="p">()</span>
    <span class="c"># 等待pw结束:</span>
    <span class="n">pw</span><span class="o">.</span><span class="n">join</span><span class="p">()</span>
    <span class="c"># pr进程里是死循环，无法等待其结束，只能强行终止:</span>
    <span class="n">pr</span><span class="o">.</span><span class="n">terminate</span><span class="p">()</span>
</pre></div>


<p>在Unix/Linux下，multiprocessing模块封装了fork()调用，使我们不需要关注fork()的细节。由于Windows没有fork调用，因此，multiprocessing需要“模拟”出fork的效果，父进程所有Python对象都必须通过pickle序列化再传到子进程去，所以，如果multiprocessing在Windows下调用失败了，要先考虑是不是pickle失败了。</p>
  <div class="relation">
    <h2>Related</h2>
    <ul>
    
    <li><a href="/wiki/tools/anaconda_python_notes.html">Anaconda notes</a></li>
    
    <li><a href="/wiki/programming_language/python_oop.html">Python 面向对象编程</a></li>
    
    <li><a href="/wiki/programming_language/python_basics_notes.html">Python Basics Notes</a></li>
    
    <li><a href="/wiki/programming_language/python_modules.html">Python 中的模块</a></li>
    
    <li><a href="/wiki/programming_language/python_debugging_and_tests.html">Python 错误处理与测试</a></li>
    
    <li><a href="/wiki/programming_language/python_fp_notes.html">Python 函数式编程</a></li>
    
    <li><a href="/wiki/programming_language/python_IO.html">Python IO 编程</a></li>
    
    </ul>
  </div>
    </div>
    <div id="footer">
      <span>
        <p>Copyright © 2019 Yilin Gui.
        Powered by <a href="http://simiki.org/" target="_blank">Simiki</a>.</p>
        <p>Site Generated 2019-11-14 01:54:04</p>
      </span>
    </div>

    
    
  </body>
</html>